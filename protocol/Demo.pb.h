// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Demo.proto

#ifndef PROTOBUF_Demo_2eproto__INCLUDED
#define PROTOBUF_Demo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace PWRD {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Demo_2eproto();
void protobuf_AssignDesc_Demo_2eproto();
void protobuf_ShutdownFile_Demo_2eproto();

class RegistryItem;
class Dress;
class Prop;
class Energy;
class Property;
class Exception;
class Stat;
class PKListBlock;
class PKListStat;
class PKList;
class Request;
class Response;
class Fight;
class FightResult;
class Mail;
class File;

enum TYPE {
  HA = 1,
  MAIL = 2,
  LOST = 3,
  STORE = 4,
  PKLIST = 5,
  SHITLIST = 6,
  REGISTRY = 7,
  PROPERTY = 8,
  FIGHTING = 9,
  FIGHTREQUEST = 10,
  FIGHTRESPONSE = 11,
  SNSFRIENDS = 12,
  PROPATTACK = 13,
  CONFIGFILE = 14,
  FIGHTRESULT = 15,
  FIGHTHISTORY = 16,
  VERSION = 17
};
bool TYPE_IsValid(int value);
const TYPE TYPE_MIN = HA;
const TYPE TYPE_MAX = VERSION;
const int TYPE_ARRAYSIZE = TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* TYPE_descriptor();
inline const ::std::string& TYPE_Name(TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    TYPE_descriptor(), value);
}
inline bool TYPE_Parse(
    const ::std::string& name, TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TYPE>(
    TYPE_descriptor(), name, value);
}
enum STAT {
  FIGHT = 1,
  BUSY = 2,
  IDLE = 3
};
bool STAT_IsValid(int value);
const STAT STAT_MIN = FIGHT;
const STAT STAT_MAX = IDLE;
const int STAT_ARRAYSIZE = STAT_MAX + 1;

const ::google::protobuf::EnumDescriptor* STAT_descriptor();
inline const ::std::string& STAT_Name(STAT value) {
  return ::google::protobuf::internal::NameOfEnum(
    STAT_descriptor(), value);
}
inline bool STAT_Parse(
    const ::std::string& name, STAT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<STAT>(
    STAT_descriptor(), name, value);
}
// ===================================================================

class RegistryItem : public ::google::protobuf::Message {
 public:
  RegistryItem();
  virtual ~RegistryItem();
  
  RegistryItem(const RegistryItem& from);
  
  inline RegistryItem& operator=(const RegistryItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegistryItem& default_instance();
  
  void Swap(RegistryItem* other);
  
  // implements Message ----------------------------------------------
  
  RegistryItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegistryItem& from);
  void MergeFrom(const RegistryItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // required string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:PWRD.RegistryItem)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Demo_2eproto();
  friend void protobuf_AssignDesc_Demo_2eproto();
  friend void protobuf_ShutdownFile_Demo_2eproto();
  
  void InitAsDefaultInstance();
  static RegistryItem* default_instance_;
};
// -------------------------------------------------------------------

class Dress : public ::google::protobuf::Message {
 public:
  Dress();
  virtual ~Dress();
  
  Dress(const Dress& from);
  
  inline Dress& operator=(const Dress& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Dress& default_instance();
  
  void Swap(Dress* other);
  
  // implements Message ----------------------------------------------
  
  Dress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Dress& from);
  void MergeFrom(const Dress& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);
  
  // required int32 defense = 2;
  inline bool has_defense() const;
  inline void clear_defense();
  static const int kDefenseFieldNumber = 2;
  inline ::google::protobuf::int32 defense() const;
  inline void set_defense(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PWRD.Dress)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_defense();
  inline void clear_has_defense();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 defense_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Demo_2eproto();
  friend void protobuf_AssignDesc_Demo_2eproto();
  friend void protobuf_ShutdownFile_Demo_2eproto();
  
  void InitAsDefaultInstance();
  static Dress* default_instance_;
};
// -------------------------------------------------------------------

class Prop : public ::google::protobuf::Message {
 public:
  Prop();
  virtual ~Prop();
  
  Prop(const Prop& from);
  
  inline Prop& operator=(const Prop& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Prop& default_instance();
  
  void Swap(Prop* other);
  
  // implements Message ----------------------------------------------
  
  Prop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Prop& from);
  void MergeFrom(const Prop& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required int32 harm = 2;
  inline bool has_harm() const;
  inline void clear_harm();
  static const int kHarmFieldNumber = 2;
  inline ::google::protobuf::int32 harm() const;
  inline void set_harm(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PWRD.Prop)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_harm();
  inline void clear_has_harm();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 harm_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Demo_2eproto();
  friend void protobuf_AssignDesc_Demo_2eproto();
  friend void protobuf_ShutdownFile_Demo_2eproto();
  
  void InitAsDefaultInstance();
  static Prop* default_instance_;
};
// -------------------------------------------------------------------

class Energy : public ::google::protobuf::Message {
 public:
  Energy();
  virtual ~Energy();
  
  Energy(const Energy& from);
  
  inline Energy& operator=(const Energy& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Energy& default_instance();
  
  void Swap(Energy* other);
  
  // implements Message ----------------------------------------------
  
  Energy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Energy& from);
  void MergeFrom(const Energy& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 defense = 2;
  inline bool has_defense() const;
  inline void clear_defense();
  static const int kDefenseFieldNumber = 2;
  inline ::google::protobuf::int32 defense() const;
  inline void set_defense(::google::protobuf::int32 value);
  
  // optional int32 addhp = 3;
  inline bool has_addhp() const;
  inline void clear_addhp();
  static const int kAddhpFieldNumber = 3;
  inline ::google::protobuf::int32 addhp() const;
  inline void set_addhp(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PWRD.Energy)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_defense();
  inline void clear_has_defense();
  inline void set_has_addhp();
  inline void clear_has_addhp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 defense_;
  ::google::protobuf::int32 addhp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Demo_2eproto();
  friend void protobuf_AssignDesc_Demo_2eproto();
  friend void protobuf_ShutdownFile_Demo_2eproto();
  
  void InitAsDefaultInstance();
  static Energy* default_instance_;
};
// -------------------------------------------------------------------

class Property : public ::google::protobuf::Message {
 public:
  Property();
  virtual ~Property();
  
  Property(const Property& from);
  
  inline Property& operator=(const Property& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Property& default_instance();
  
  void Swap(Property* other);
  
  // implements Message ----------------------------------------------
  
  Property* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Property& from);
  void MergeFrom(const Property& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 hp = 3;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 3;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);
  
  // required int32 rank = 4;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 4;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);
  
  // required int32 faint = 5;
  inline bool has_faint() const;
  inline void clear_faint();
  static const int kFaintFieldNumber = 5;
  inline ::google::protobuf::int32 faint() const;
  inline void set_faint(::google::protobuf::int32 value);
  
  // repeated .PWRD.Dress dress = 6;
  inline int dress_size() const;
  inline void clear_dress();
  static const int kDressFieldNumber = 6;
  inline const ::PWRD::Dress& dress(int index) const;
  inline ::PWRD::Dress* mutable_dress(int index);
  inline ::PWRD::Dress* add_dress();
  inline const ::google::protobuf::RepeatedPtrField< ::PWRD::Dress >&
      dress() const;
  inline ::google::protobuf::RepeatedPtrField< ::PWRD::Dress >*
      mutable_dress();
  
  // repeated .PWRD.Prop prop = 7;
  inline int prop_size() const;
  inline void clear_prop();
  static const int kPropFieldNumber = 7;
  inline const ::PWRD::Prop& prop(int index) const;
  inline ::PWRD::Prop* mutable_prop(int index);
  inline ::PWRD::Prop* add_prop();
  inline const ::google::protobuf::RepeatedPtrField< ::PWRD::Prop >&
      prop() const;
  inline ::google::protobuf::RepeatedPtrField< ::PWRD::Prop >*
      mutable_prop();
  
  // repeated .PWRD.Energy energy = 8;
  inline int energy_size() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 8;
  inline const ::PWRD::Energy& energy(int index) const;
  inline ::PWRD::Energy* mutable_energy(int index);
  inline ::PWRD::Energy* add_energy();
  inline const ::google::protobuf::RepeatedPtrField< ::PWRD::Energy >&
      energy() const;
  inline ::google::protobuf::RepeatedPtrField< ::PWRD::Energy >*
      mutable_energy();
  
  // @@protoc_insertion_point(class_scope:PWRD.Property)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_faint();
  inline void clear_has_faint();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  ::std::string* name_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 rank_;
  ::google::protobuf::RepeatedPtrField< ::PWRD::Dress > dress_;
  ::google::protobuf::RepeatedPtrField< ::PWRD::Prop > prop_;
  ::google::protobuf::RepeatedPtrField< ::PWRD::Energy > energy_;
  ::google::protobuf::int32 faint_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_Demo_2eproto();
  friend void protobuf_AssignDesc_Demo_2eproto();
  friend void protobuf_ShutdownFile_Demo_2eproto();
  
  void InitAsDefaultInstance();
  static Property* default_instance_;
};
// -------------------------------------------------------------------

class Exception : public ::google::protobuf::Message {
 public:
  Exception();
  virtual ~Exception();
  
  Exception(const Exception& from);
  
  inline Exception& operator=(const Exception& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Exception& default_instance();
  
  void Swap(Exception* other);
  
  // implements Message ----------------------------------------------
  
  Exception* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Exception& from);
  void MergeFrom(const Exception& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 exp_id = 1;
  inline bool has_exp_id() const;
  inline void clear_exp_id();
  static const int kExpIdFieldNumber = 1;
  inline ::google::protobuf::int32 exp_id() const;
  inline void set_exp_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PWRD.Exception)
 private:
  inline void set_has_exp_id();
  inline void clear_has_exp_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 exp_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Demo_2eproto();
  friend void protobuf_AssignDesc_Demo_2eproto();
  friend void protobuf_ShutdownFile_Demo_2eproto();
  
  void InitAsDefaultInstance();
  static Exception* default_instance_;
};
// -------------------------------------------------------------------

class Stat : public ::google::protobuf::Message {
 public:
  Stat();
  virtual ~Stat();
  
  Stat(const Stat& from);
  
  inline Stat& operator=(const Stat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Stat& default_instance();
  
  void Swap(Stat* other);
  
  // implements Message ----------------------------------------------
  
  Stat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stat& from);
  void MergeFrom(const Stat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // required .PWRD.STAT stat = 2;
  inline bool has_stat() const;
  inline void clear_stat();
  static const int kStatFieldNumber = 2;
  inline PWRD::STAT stat() const;
  inline void set_stat(PWRD::STAT value);
  
  // @@protoc_insertion_point(class_scope:PWRD.Stat)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_stat();
  inline void clear_has_stat();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  int stat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Demo_2eproto();
  friend void protobuf_AssignDesc_Demo_2eproto();
  friend void protobuf_ShutdownFile_Demo_2eproto();
  
  void InitAsDefaultInstance();
  static Stat* default_instance_;
};
// -------------------------------------------------------------------

class PKListBlock : public ::google::protobuf::Message {
 public:
  PKListBlock();
  virtual ~PKListBlock();
  
  PKListBlock(const PKListBlock& from);
  
  inline PKListBlock& operator=(const PKListBlock& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PKListBlock& default_instance();
  
  void Swap(PKListBlock* other);
  
  // implements Message ----------------------------------------------
  
  PKListBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PKListBlock& from);
  void MergeFrom(const PKListBlock& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PWRD.Property property = 1;
  inline int property_size() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 1;
  inline const ::PWRD::Property& property(int index) const;
  inline ::PWRD::Property* mutable_property(int index);
  inline ::PWRD::Property* add_property();
  inline const ::google::protobuf::RepeatedPtrField< ::PWRD::Property >&
      property() const;
  inline ::google::protobuf::RepeatedPtrField< ::PWRD::Property >*
      mutable_property();
  
  // @@protoc_insertion_point(class_scope:PWRD.PKListBlock)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::PWRD::Property > property_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Demo_2eproto();
  friend void protobuf_AssignDesc_Demo_2eproto();
  friend void protobuf_ShutdownFile_Demo_2eproto();
  
  void InitAsDefaultInstance();
  static PKListBlock* default_instance_;
};
// -------------------------------------------------------------------

class PKListStat : public ::google::protobuf::Message {
 public:
  PKListStat();
  virtual ~PKListStat();
  
  PKListStat(const PKListStat& from);
  
  inline PKListStat& operator=(const PKListStat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PKListStat& default_instance();
  
  void Swap(PKListStat* other);
  
  // implements Message ----------------------------------------------
  
  PKListStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PKListStat& from);
  void MergeFrom(const PKListStat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PWRD.Stat stat = 1;
  inline int stat_size() const;
  inline void clear_stat();
  static const int kStatFieldNumber = 1;
  inline const ::PWRD::Stat& stat(int index) const;
  inline ::PWRD::Stat* mutable_stat(int index);
  inline ::PWRD::Stat* add_stat();
  inline const ::google::protobuf::RepeatedPtrField< ::PWRD::Stat >&
      stat() const;
  inline ::google::protobuf::RepeatedPtrField< ::PWRD::Stat >*
      mutable_stat();
  
  // @@protoc_insertion_point(class_scope:PWRD.PKListStat)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::PWRD::Stat > stat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Demo_2eproto();
  friend void protobuf_AssignDesc_Demo_2eproto();
  friend void protobuf_ShutdownFile_Demo_2eproto();
  
  void InitAsDefaultInstance();
  static PKListStat* default_instance_;
};
// -------------------------------------------------------------------

class PKList : public ::google::protobuf::Message {
 public:
  PKList();
  virtual ~PKList();
  
  PKList(const PKList& from);
  
  inline PKList& operator=(const PKList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PKList& default_instance();
  
  void Swap(PKList* other);
  
  // implements Message ----------------------------------------------
  
  PKList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PKList& from);
  void MergeFrom(const PKList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .PWRD.PKListBlock block = 1;
  inline bool has_block() const;
  inline void clear_block();
  static const int kBlockFieldNumber = 1;
  inline const ::PWRD::PKListBlock& block() const;
  inline ::PWRD::PKListBlock* mutable_block();
  inline ::PWRD::PKListBlock* release_block();
  
  // required .PWRD.PKListStat stat = 2;
  inline bool has_stat() const;
  inline void clear_stat();
  static const int kStatFieldNumber = 2;
  inline const ::PWRD::PKListStat& stat() const;
  inline ::PWRD::PKListStat* mutable_stat();
  inline ::PWRD::PKListStat* release_stat();
  
  // @@protoc_insertion_point(class_scope:PWRD.PKList)
 private:
  inline void set_has_block();
  inline void clear_has_block();
  inline void set_has_stat();
  inline void clear_has_stat();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::PWRD::PKListBlock* block_;
  ::PWRD::PKListStat* stat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Demo_2eproto();
  friend void protobuf_AssignDesc_Demo_2eproto();
  friend void protobuf_ShutdownFile_Demo_2eproto();
  
  void InitAsDefaultInstance();
  static PKList* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();
  
  Request(const Request& from);
  
  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();
  
  void Swap(Request* other);
  
  // implements Message ----------------------------------------------
  
  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string fid = 1;
  inline bool has_fid() const;
  inline void clear_fid();
  static const int kFidFieldNumber = 1;
  inline const ::std::string& fid() const;
  inline void set_fid(const ::std::string& value);
  inline void set_fid(const char* value);
  inline void set_fid(const char* value, size_t size);
  inline ::std::string* mutable_fid();
  inline ::std::string* release_fid();
  
  // @@protoc_insertion_point(class_scope:PWRD.Request)
 private:
  inline void set_has_fid();
  inline void clear_has_fid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* fid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Demo_2eproto();
  friend void protobuf_AssignDesc_Demo_2eproto();
  friend void protobuf_ShutdownFile_Demo_2eproto();
  
  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();
  
  Response(const Response& from);
  
  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();
  
  void Swap(Response* other);
  
  // implements Message ----------------------------------------------
  
  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required string fid = 2;
  inline bool has_fid() const;
  inline void clear_fid();
  static const int kFidFieldNumber = 2;
  inline const ::std::string& fid() const;
  inline void set_fid(const ::std::string& value);
  inline void set_fid(const char* value);
  inline void set_fid(const char* value, size_t size);
  inline ::std::string* mutable_fid();
  inline ::std::string* release_fid();
  
  // required bool ido = 3;
  inline bool has_ido() const;
  inline void clear_ido();
  static const int kIdoFieldNumber = 3;
  inline bool ido() const;
  inline void set_ido(bool value);
  
  // @@protoc_insertion_point(class_scope:PWRD.Response)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_fid();
  inline void clear_has_fid();
  inline void set_has_ido();
  inline void clear_has_ido();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::std::string* fid_;
  bool ido_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Demo_2eproto();
  friend void protobuf_AssignDesc_Demo_2eproto();
  friend void protobuf_ShutdownFile_Demo_2eproto();
  
  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Fight : public ::google::protobuf::Message {
 public:
  Fight();
  virtual ~Fight();
  
  Fight(const Fight& from);
  
  inline Fight& operator=(const Fight& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Fight& default_instance();
  
  void Swap(Fight* other);
  
  // implements Message ----------------------------------------------
  
  Fight* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Fight& from);
  void MergeFrom(const Fight& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 boxing = 1;
  inline bool has_boxing() const;
  inline void clear_boxing();
  static const int kBoxingFieldNumber = 1;
  inline ::google::protobuf::int32 boxing() const;
  inline void set_boxing(::google::protobuf::int32 value);
  
  // required int32 hp = 2;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 2;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);
  
  // optional .PWRD.Prop prop = 3;
  inline bool has_prop() const;
  inline void clear_prop();
  static const int kPropFieldNumber = 3;
  inline const ::PWRD::Prop& prop() const;
  inline ::PWRD::Prop* mutable_prop();
  inline ::PWRD::Prop* release_prop();
  
  // optional .PWRD.Exception exp = 4;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 4;
  inline const ::PWRD::Exception& exp() const;
  inline ::PWRD::Exception* mutable_exp();
  inline ::PWRD::Exception* release_exp();
  
  // @@protoc_insertion_point(class_scope:PWRD.Fight)
 private:
  inline void set_has_boxing();
  inline void clear_has_boxing();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_prop();
  inline void clear_has_prop();
  inline void set_has_exp();
  inline void clear_has_exp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 boxing_;
  ::google::protobuf::int32 hp_;
  ::PWRD::Prop* prop_;
  ::PWRD::Exception* exp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Demo_2eproto();
  friend void protobuf_AssignDesc_Demo_2eproto();
  friend void protobuf_ShutdownFile_Demo_2eproto();
  
  void InitAsDefaultInstance();
  static Fight* default_instance_;
};
// -------------------------------------------------------------------

class FightResult : public ::google::protobuf::Message {
 public:
  FightResult();
  virtual ~FightResult();
  
  FightResult(const FightResult& from);
  
  inline FightResult& operator=(const FightResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FightResult& default_instance();
  
  void Swap(FightResult* other);
  
  // implements Message ----------------------------------------------
  
  FightResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FightResult& from);
  void MergeFrom(const FightResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // required int32 experience = 2;
  inline bool has_experience() const;
  inline void clear_experience();
  static const int kExperienceFieldNumber = 2;
  inline ::google::protobuf::int32 experience() const;
  inline void set_experience(::google::protobuf::int32 value);
  
  // required int32 bonus = 3;
  inline bool has_bonus() const;
  inline void clear_bonus();
  static const int kBonusFieldNumber = 3;
  inline ::google::protobuf::int32 bonus() const;
  inline void set_bonus(::google::protobuf::int32 value);
  
  // required bool clear = 4;
  inline bool has_clear() const;
  inline void clear_clear();
  static const int kClearFieldNumber = 4;
  inline bool clear() const;
  inline void set_clear(bool value);
  
  // @@protoc_insertion_point(class_scope:PWRD.FightResult)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_experience();
  inline void clear_has_experience();
  inline void set_has_bonus();
  inline void clear_has_bonus();
  inline void set_has_clear();
  inline void clear_has_clear();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  ::google::protobuf::int32 experience_;
  ::google::protobuf::int32 bonus_;
  bool clear_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Demo_2eproto();
  friend void protobuf_AssignDesc_Demo_2eproto();
  friend void protobuf_ShutdownFile_Demo_2eproto();
  
  void InitAsDefaultInstance();
  static FightResult* default_instance_;
};
// -------------------------------------------------------------------

class Mail : public ::google::protobuf::Message {
 public:
  Mail();
  virtual ~Mail();
  
  Mail(const Mail& from);
  
  inline Mail& operator=(const Mail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mail& default_instance();
  
  void Swap(Mail* other);
  
  // implements Message ----------------------------------------------
  
  Mail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mail& from);
  void MergeFrom(const Mail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // required string mail = 2;
  inline bool has_mail() const;
  inline void clear_mail();
  static const int kMailFieldNumber = 2;
  inline const ::std::string& mail() const;
  inline void set_mail(const ::std::string& value);
  inline void set_mail(const char* value);
  inline void set_mail(const char* value, size_t size);
  inline ::std::string* mutable_mail();
  inline ::std::string* release_mail();
  
  // @@protoc_insertion_point(class_scope:PWRD.Mail)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_mail();
  inline void clear_has_mail();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  ::std::string* mail_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Demo_2eproto();
  friend void protobuf_AssignDesc_Demo_2eproto();
  friend void protobuf_ShutdownFile_Demo_2eproto();
  
  void InitAsDefaultInstance();
  static Mail* default_instance_;
};
// -------------------------------------------------------------------

class File : public ::google::protobuf::Message {
 public:
  File();
  virtual ~File();
  
  File(const File& from);
  
  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const File& default_instance();
  
  void Swap(File* other);
  
  // implements Message ----------------------------------------------
  
  File* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // required bool match = 2;
  inline bool has_match() const;
  inline void clear_match();
  static const int kMatchFieldNumber = 2;
  inline bool match() const;
  inline void set_match(bool value);
  
  // optional string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  
  // optional string content = 4;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 4;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  
  // optional string md5sum = 5;
  inline bool has_md5sum() const;
  inline void clear_md5sum();
  static const int kMd5SumFieldNumber = 5;
  inline const ::std::string& md5sum() const;
  inline void set_md5sum(const ::std::string& value);
  inline void set_md5sum(const char* value);
  inline void set_md5sum(const char* value, size_t size);
  inline ::std::string* mutable_md5sum();
  inline ::std::string* release_md5sum();
  
  // @@protoc_insertion_point(class_scope:PWRD.File)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_match();
  inline void clear_has_match();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_md5sum();
  inline void clear_has_md5sum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  ::std::string* path_;
  ::std::string* content_;
  ::std::string* md5sum_;
  bool match_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Demo_2eproto();
  friend void protobuf_AssignDesc_Demo_2eproto();
  friend void protobuf_ShutdownFile_Demo_2eproto();
  
  void InitAsDefaultInstance();
  static File* default_instance_;
};
// ===================================================================


// ===================================================================

// RegistryItem

// required string uid = 1;
inline bool RegistryItem::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistryItem::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegistryItem::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegistryItem::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RegistryItem::uid() const {
  return *uid_;
}
inline void RegistryItem::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RegistryItem::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RegistryItem::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistryItem::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RegistryItem::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string version = 2;
inline bool RegistryItem::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegistryItem::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegistryItem::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegistryItem::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& RegistryItem::version() const {
  return *version_;
}
inline void RegistryItem::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RegistryItem::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void RegistryItem::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistryItem::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* RegistryItem::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Dress

// required int32 uid = 1;
inline bool Dress::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Dress::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Dress::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Dress::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 Dress::uid() const {
  return uid_;
}
inline void Dress::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// required int32 defense = 2;
inline bool Dress::has_defense() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Dress::set_has_defense() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Dress::clear_has_defense() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Dress::clear_defense() {
  defense_ = 0;
  clear_has_defense();
}
inline ::google::protobuf::int32 Dress::defense() const {
  return defense_;
}
inline void Dress::set_defense(::google::protobuf::int32 value) {
  set_has_defense();
  defense_ = value;
}

// -------------------------------------------------------------------

// Prop

// required int32 id = 1;
inline bool Prop::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Prop::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Prop::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Prop::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Prop::id() const {
  return id_;
}
inline void Prop::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 harm = 2;
inline bool Prop::has_harm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Prop::set_has_harm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Prop::clear_has_harm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Prop::clear_harm() {
  harm_ = 0;
  clear_has_harm();
}
inline ::google::protobuf::int32 Prop::harm() const {
  return harm_;
}
inline void Prop::set_harm(::google::protobuf::int32 value) {
  set_has_harm();
  harm_ = value;
}

// -------------------------------------------------------------------

// Energy

// required int32 id = 1;
inline bool Energy::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Energy::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Energy::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Energy::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Energy::id() const {
  return id_;
}
inline void Energy::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 defense = 2;
inline bool Energy::has_defense() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Energy::set_has_defense() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Energy::clear_has_defense() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Energy::clear_defense() {
  defense_ = 0;
  clear_has_defense();
}
inline ::google::protobuf::int32 Energy::defense() const {
  return defense_;
}
inline void Energy::set_defense(::google::protobuf::int32 value) {
  set_has_defense();
  defense_ = value;
}

// optional int32 addhp = 3;
inline bool Energy::has_addhp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Energy::set_has_addhp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Energy::clear_has_addhp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Energy::clear_addhp() {
  addhp_ = 0;
  clear_has_addhp();
}
inline ::google::protobuf::int32 Energy::addhp() const {
  return addhp_;
}
inline void Energy::set_addhp(::google::protobuf::int32 value) {
  set_has_addhp();
  addhp_ = value;
}

// -------------------------------------------------------------------

// Property

// required string uid = 1;
inline bool Property::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Property::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Property::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Property::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& Property::uid() const {
  return *uid_;
}
inline void Property::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void Property::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void Property::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* Property::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool Property::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Property::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Property::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Property::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Property::name() const {
  return *name_;
}
inline void Property::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Property::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Property::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Property::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Property::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 hp = 3;
inline bool Property::has_hp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Property::set_has_hp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Property::clear_has_hp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Property::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 Property::hp() const {
  return hp_;
}
inline void Property::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// required int32 rank = 4;
inline bool Property::has_rank() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Property::set_has_rank() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Property::clear_has_rank() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Property::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 Property::rank() const {
  return rank_;
}
inline void Property::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// required int32 faint = 5;
inline bool Property::has_faint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Property::set_has_faint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Property::clear_has_faint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Property::clear_faint() {
  faint_ = 0;
  clear_has_faint();
}
inline ::google::protobuf::int32 Property::faint() const {
  return faint_;
}
inline void Property::set_faint(::google::protobuf::int32 value) {
  set_has_faint();
  faint_ = value;
}

// repeated .PWRD.Dress dress = 6;
inline int Property::dress_size() const {
  return dress_.size();
}
inline void Property::clear_dress() {
  dress_.Clear();
}
inline const ::PWRD::Dress& Property::dress(int index) const {
  return dress_.Get(index);
}
inline ::PWRD::Dress* Property::mutable_dress(int index) {
  return dress_.Mutable(index);
}
inline ::PWRD::Dress* Property::add_dress() {
  return dress_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PWRD::Dress >&
Property::dress() const {
  return dress_;
}
inline ::google::protobuf::RepeatedPtrField< ::PWRD::Dress >*
Property::mutable_dress() {
  return &dress_;
}

// repeated .PWRD.Prop prop = 7;
inline int Property::prop_size() const {
  return prop_.size();
}
inline void Property::clear_prop() {
  prop_.Clear();
}
inline const ::PWRD::Prop& Property::prop(int index) const {
  return prop_.Get(index);
}
inline ::PWRD::Prop* Property::mutable_prop(int index) {
  return prop_.Mutable(index);
}
inline ::PWRD::Prop* Property::add_prop() {
  return prop_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PWRD::Prop >&
Property::prop() const {
  return prop_;
}
inline ::google::protobuf::RepeatedPtrField< ::PWRD::Prop >*
Property::mutable_prop() {
  return &prop_;
}

// repeated .PWRD.Energy energy = 8;
inline int Property::energy_size() const {
  return energy_.size();
}
inline void Property::clear_energy() {
  energy_.Clear();
}
inline const ::PWRD::Energy& Property::energy(int index) const {
  return energy_.Get(index);
}
inline ::PWRD::Energy* Property::mutable_energy(int index) {
  return energy_.Mutable(index);
}
inline ::PWRD::Energy* Property::add_energy() {
  return energy_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PWRD::Energy >&
Property::energy() const {
  return energy_;
}
inline ::google::protobuf::RepeatedPtrField< ::PWRD::Energy >*
Property::mutable_energy() {
  return &energy_;
}

// -------------------------------------------------------------------

// Exception

// required int32 exp_id = 1;
inline bool Exception::has_exp_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Exception::set_has_exp_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Exception::clear_has_exp_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Exception::clear_exp_id() {
  exp_id_ = 0;
  clear_has_exp_id();
}
inline ::google::protobuf::int32 Exception::exp_id() const {
  return exp_id_;
}
inline void Exception::set_exp_id(::google::protobuf::int32 value) {
  set_has_exp_id();
  exp_id_ = value;
}

// -------------------------------------------------------------------

// Stat

// required string uid = 1;
inline bool Stat::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stat::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stat::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stat::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& Stat::uid() const {
  return *uid_;
}
inline void Stat::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void Stat::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void Stat::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Stat::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* Stat::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .PWRD.STAT stat = 2;
inline bool Stat::has_stat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stat::set_has_stat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stat::clear_has_stat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stat::clear_stat() {
  stat_ = 1;
  clear_has_stat();
}
inline PWRD::STAT Stat::stat() const {
  return static_cast< PWRD::STAT >(stat_);
}
inline void Stat::set_stat(PWRD::STAT value) {
  GOOGLE_DCHECK(PWRD::STAT_IsValid(value));
  set_has_stat();
  stat_ = value;
}

// -------------------------------------------------------------------

// PKListBlock

// repeated .PWRD.Property property = 1;
inline int PKListBlock::property_size() const {
  return property_.size();
}
inline void PKListBlock::clear_property() {
  property_.Clear();
}
inline const ::PWRD::Property& PKListBlock::property(int index) const {
  return property_.Get(index);
}
inline ::PWRD::Property* PKListBlock::mutable_property(int index) {
  return property_.Mutable(index);
}
inline ::PWRD::Property* PKListBlock::add_property() {
  return property_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PWRD::Property >&
PKListBlock::property() const {
  return property_;
}
inline ::google::protobuf::RepeatedPtrField< ::PWRD::Property >*
PKListBlock::mutable_property() {
  return &property_;
}

// -------------------------------------------------------------------

// PKListStat

// repeated .PWRD.Stat stat = 1;
inline int PKListStat::stat_size() const {
  return stat_.size();
}
inline void PKListStat::clear_stat() {
  stat_.Clear();
}
inline const ::PWRD::Stat& PKListStat::stat(int index) const {
  return stat_.Get(index);
}
inline ::PWRD::Stat* PKListStat::mutable_stat(int index) {
  return stat_.Mutable(index);
}
inline ::PWRD::Stat* PKListStat::add_stat() {
  return stat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PWRD::Stat >&
PKListStat::stat() const {
  return stat_;
}
inline ::google::protobuf::RepeatedPtrField< ::PWRD::Stat >*
PKListStat::mutable_stat() {
  return &stat_;
}

// -------------------------------------------------------------------

// PKList

// required .PWRD.PKListBlock block = 1;
inline bool PKList::has_block() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKList::set_has_block() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKList::clear_has_block() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKList::clear_block() {
  if (block_ != NULL) block_->::PWRD::PKListBlock::Clear();
  clear_has_block();
}
inline const ::PWRD::PKListBlock& PKList::block() const {
  return block_ != NULL ? *block_ : *default_instance_->block_;
}
inline ::PWRD::PKListBlock* PKList::mutable_block() {
  set_has_block();
  if (block_ == NULL) block_ = new ::PWRD::PKListBlock;
  return block_;
}
inline ::PWRD::PKListBlock* PKList::release_block() {
  clear_has_block();
  ::PWRD::PKListBlock* temp = block_;
  block_ = NULL;
  return temp;
}

// required .PWRD.PKListStat stat = 2;
inline bool PKList::has_stat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKList::set_has_stat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKList::clear_has_stat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKList::clear_stat() {
  if (stat_ != NULL) stat_->::PWRD::PKListStat::Clear();
  clear_has_stat();
}
inline const ::PWRD::PKListStat& PKList::stat() const {
  return stat_ != NULL ? *stat_ : *default_instance_->stat_;
}
inline ::PWRD::PKListStat* PKList::mutable_stat() {
  set_has_stat();
  if (stat_ == NULL) stat_ = new ::PWRD::PKListStat;
  return stat_;
}
inline ::PWRD::PKListStat* PKList::release_stat() {
  clear_has_stat();
  ::PWRD::PKListStat* temp = stat_;
  stat_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Request

// required string fid = 1;
inline bool Request::has_fid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_fid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_fid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_fid() {
  if (fid_ != &::google::protobuf::internal::kEmptyString) {
    fid_->clear();
  }
  clear_has_fid();
}
inline const ::std::string& Request::fid() const {
  return *fid_;
}
inline void Request::set_fid(const ::std::string& value) {
  set_has_fid();
  if (fid_ == &::google::protobuf::internal::kEmptyString) {
    fid_ = new ::std::string;
  }
  fid_->assign(value);
}
inline void Request::set_fid(const char* value) {
  set_has_fid();
  if (fid_ == &::google::protobuf::internal::kEmptyString) {
    fid_ = new ::std::string;
  }
  fid_->assign(value);
}
inline void Request::set_fid(const char* value, size_t size) {
  set_has_fid();
  if (fid_ == &::google::protobuf::internal::kEmptyString) {
    fid_ = new ::std::string;
  }
  fid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_fid() {
  set_has_fid();
  if (fid_ == &::google::protobuf::internal::kEmptyString) {
    fid_ = new ::std::string;
  }
  return fid_;
}
inline ::std::string* Request::release_fid() {
  clear_has_fid();
  if (fid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fid_;
    fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Response

// required string id = 1;
inline bool Response::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Response::id() const {
  return *id_;
}
inline void Response::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Response::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Response::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Response::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string fid = 2;
inline bool Response::has_fid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_fid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_fid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_fid() {
  if (fid_ != &::google::protobuf::internal::kEmptyString) {
    fid_->clear();
  }
  clear_has_fid();
}
inline const ::std::string& Response::fid() const {
  return *fid_;
}
inline void Response::set_fid(const ::std::string& value) {
  set_has_fid();
  if (fid_ == &::google::protobuf::internal::kEmptyString) {
    fid_ = new ::std::string;
  }
  fid_->assign(value);
}
inline void Response::set_fid(const char* value) {
  set_has_fid();
  if (fid_ == &::google::protobuf::internal::kEmptyString) {
    fid_ = new ::std::string;
  }
  fid_->assign(value);
}
inline void Response::set_fid(const char* value, size_t size) {
  set_has_fid();
  if (fid_ == &::google::protobuf::internal::kEmptyString) {
    fid_ = new ::std::string;
  }
  fid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response::mutable_fid() {
  set_has_fid();
  if (fid_ == &::google::protobuf::internal::kEmptyString) {
    fid_ = new ::std::string;
  }
  return fid_;
}
inline ::std::string* Response::release_fid() {
  clear_has_fid();
  if (fid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fid_;
    fid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool ido = 3;
inline bool Response::has_ido() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_ido() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_ido() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_ido() {
  ido_ = false;
  clear_has_ido();
}
inline bool Response::ido() const {
  return ido_;
}
inline void Response::set_ido(bool value) {
  set_has_ido();
  ido_ = value;
}

// -------------------------------------------------------------------

// Fight

// required int32 boxing = 1;
inline bool Fight::has_boxing() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fight::set_has_boxing() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Fight::clear_has_boxing() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Fight::clear_boxing() {
  boxing_ = 0;
  clear_has_boxing();
}
inline ::google::protobuf::int32 Fight::boxing() const {
  return boxing_;
}
inline void Fight::set_boxing(::google::protobuf::int32 value) {
  set_has_boxing();
  boxing_ = value;
}

// required int32 hp = 2;
inline bool Fight::has_hp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Fight::set_has_hp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Fight::clear_has_hp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Fight::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 Fight::hp() const {
  return hp_;
}
inline void Fight::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// optional .PWRD.Prop prop = 3;
inline bool Fight::has_prop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Fight::set_has_prop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Fight::clear_has_prop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Fight::clear_prop() {
  if (prop_ != NULL) prop_->::PWRD::Prop::Clear();
  clear_has_prop();
}
inline const ::PWRD::Prop& Fight::prop() const {
  return prop_ != NULL ? *prop_ : *default_instance_->prop_;
}
inline ::PWRD::Prop* Fight::mutable_prop() {
  set_has_prop();
  if (prop_ == NULL) prop_ = new ::PWRD::Prop;
  return prop_;
}
inline ::PWRD::Prop* Fight::release_prop() {
  clear_has_prop();
  ::PWRD::Prop* temp = prop_;
  prop_ = NULL;
  return temp;
}

// optional .PWRD.Exception exp = 4;
inline bool Fight::has_exp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Fight::set_has_exp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Fight::clear_has_exp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Fight::clear_exp() {
  if (exp_ != NULL) exp_->::PWRD::Exception::Clear();
  clear_has_exp();
}
inline const ::PWRD::Exception& Fight::exp() const {
  return exp_ != NULL ? *exp_ : *default_instance_->exp_;
}
inline ::PWRD::Exception* Fight::mutable_exp() {
  set_has_exp();
  if (exp_ == NULL) exp_ = new ::PWRD::Exception;
  return exp_;
}
inline ::PWRD::Exception* Fight::release_exp() {
  clear_has_exp();
  ::PWRD::Exception* temp = exp_;
  exp_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// FightResult

// required string uid = 1;
inline bool FightResult::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightResult::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightResult::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightResult::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& FightResult::uid() const {
  return *uid_;
}
inline void FightResult::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void FightResult::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void FightResult::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FightResult::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* FightResult::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 experience = 2;
inline bool FightResult::has_experience() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FightResult::set_has_experience() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FightResult::clear_has_experience() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FightResult::clear_experience() {
  experience_ = 0;
  clear_has_experience();
}
inline ::google::protobuf::int32 FightResult::experience() const {
  return experience_;
}
inline void FightResult::set_experience(::google::protobuf::int32 value) {
  set_has_experience();
  experience_ = value;
}

// required int32 bonus = 3;
inline bool FightResult::has_bonus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FightResult::set_has_bonus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FightResult::clear_has_bonus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FightResult::clear_bonus() {
  bonus_ = 0;
  clear_has_bonus();
}
inline ::google::protobuf::int32 FightResult::bonus() const {
  return bonus_;
}
inline void FightResult::set_bonus(::google::protobuf::int32 value) {
  set_has_bonus();
  bonus_ = value;
}

// required bool clear = 4;
inline bool FightResult::has_clear() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FightResult::set_has_clear() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FightResult::clear_has_clear() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FightResult::clear_clear() {
  clear_ = false;
  clear_has_clear();
}
inline bool FightResult::clear() const {
  return clear_;
}
inline void FightResult::set_clear(bool value) {
  set_has_clear();
  clear_ = value;
}

// -------------------------------------------------------------------

// Mail

// required string uid = 1;
inline bool Mail::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mail::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mail::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mail::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& Mail::uid() const {
  return *uid_;
}
inline void Mail::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void Mail::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void Mail::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Mail::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* Mail::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string mail = 2;
inline bool Mail::has_mail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mail::set_has_mail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mail::clear_has_mail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mail::clear_mail() {
  if (mail_ != &::google::protobuf::internal::kEmptyString) {
    mail_->clear();
  }
  clear_has_mail();
}
inline const ::std::string& Mail::mail() const {
  return *mail_;
}
inline void Mail::set_mail(const ::std::string& value) {
  set_has_mail();
  if (mail_ == &::google::protobuf::internal::kEmptyString) {
    mail_ = new ::std::string;
  }
  mail_->assign(value);
}
inline void Mail::set_mail(const char* value) {
  set_has_mail();
  if (mail_ == &::google::protobuf::internal::kEmptyString) {
    mail_ = new ::std::string;
  }
  mail_->assign(value);
}
inline void Mail::set_mail(const char* value, size_t size) {
  set_has_mail();
  if (mail_ == &::google::protobuf::internal::kEmptyString) {
    mail_ = new ::std::string;
  }
  mail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Mail::mutable_mail() {
  set_has_mail();
  if (mail_ == &::google::protobuf::internal::kEmptyString) {
    mail_ = new ::std::string;
  }
  return mail_;
}
inline ::std::string* Mail::release_mail() {
  clear_has_mail();
  if (mail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mail_;
    mail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// File

// required string uid = 1;
inline bool File::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void File::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void File::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void File::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& File::uid() const {
  return *uid_;
}
inline void File::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void File::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void File::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* File::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool match = 2;
inline bool File::has_match() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void File::set_has_match() {
  _has_bits_[0] |= 0x00000002u;
}
inline void File::clear_has_match() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void File::clear_match() {
  match_ = false;
  clear_has_match();
}
inline bool File::match() const {
  return match_;
}
inline void File::set_match(bool value) {
  set_has_match();
  match_ = value;
}

// optional string path = 3;
inline bool File::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void File::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void File::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void File::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& File::path() const {
  return *path_;
}
inline void File::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void File::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void File::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* File::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string content = 4;
inline bool File::has_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void File::set_has_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void File::clear_has_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void File::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& File::content() const {
  return *content_;
}
inline void File::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void File::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void File::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* File::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string md5sum = 5;
inline bool File::has_md5sum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void File::set_has_md5sum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void File::clear_has_md5sum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void File::clear_md5sum() {
  if (md5sum_ != &::google::protobuf::internal::kEmptyString) {
    md5sum_->clear();
  }
  clear_has_md5sum();
}
inline const ::std::string& File::md5sum() const {
  return *md5sum_;
}
inline void File::set_md5sum(const ::std::string& value) {
  set_has_md5sum();
  if (md5sum_ == &::google::protobuf::internal::kEmptyString) {
    md5sum_ = new ::std::string;
  }
  md5sum_->assign(value);
}
inline void File::set_md5sum(const char* value) {
  set_has_md5sum();
  if (md5sum_ == &::google::protobuf::internal::kEmptyString) {
    md5sum_ = new ::std::string;
  }
  md5sum_->assign(value);
}
inline void File::set_md5sum(const char* value, size_t size) {
  set_has_md5sum();
  if (md5sum_ == &::google::protobuf::internal::kEmptyString) {
    md5sum_ = new ::std::string;
  }
  md5sum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_md5sum() {
  set_has_md5sum();
  if (md5sum_ == &::google::protobuf::internal::kEmptyString) {
    md5sum_ = new ::std::string;
  }
  return md5sum_;
}
inline ::std::string* File::release_md5sum() {
  clear_has_md5sum();
  if (md5sum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = md5sum_;
    md5sum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace PWRD

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< PWRD::TYPE>() {
  return PWRD::TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< PWRD::STAT>() {
  return PWRD::STAT_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Demo_2eproto__INCLUDED
