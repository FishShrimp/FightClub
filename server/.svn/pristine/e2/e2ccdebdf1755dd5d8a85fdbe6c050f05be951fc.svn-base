// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FightClub.proto

#ifndef PROTOBUF_FightClub_2eproto__INCLUDED
#define PROTOBUF_FightClub_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace PWRD {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FightClub_2eproto();
void protobuf_AssignDesc_FightClub_2eproto();
void protobuf_ShutdownFile_FightClub_2eproto();

class File;
class Status;
class C2S_FileStatus;
class S2C_FileList;
class C2S_Version;
class S2C_Version;
class C2S_Registe;
class S2C_Registe;
class C2S_Login;
class S2C_Login;
class C2S_Room;
class S2C_Room;
class C2S_TimeStamp;
class S2C_TimeStamp;
class Equipment;
class C2S_Property;
class S2C_Property;
class PKProperty;
class C2S_PKList;
class PKTop;
class PKTopList;
class C2S_Bill;
class S2C_Bill;
class S2C_Gold;
class C2S_Money;
class C2S_PKStat;
class S2C_PKStat;
class S2C_PKList;
class C2S_FightRequest;
class S2C_FightRequest;
class C2S_FightResponse;
class S2C_FightResponse;
class Beat;
class C2S_Fight;
class S2C_Fight;
class C2S_HardBeat;
class S2C_HardBeat;
class QTE_Beat;
class C2S_QTE;
class S2C_QTE;
class C2S_Item;
class S2C_Item;
class S2C_FightResult;
class C2S_FightResult;
class C2S_Friend;
class S2C_Friend;
class C2S_AddFriend;
class S2C_AddFriend;

enum TYPE {
  HA = 100,
  LOST = 1,
  REGISTRY = 2,
  FILELIST = 3,
  PKLIST = 4,
  PKSTAT = 5,
  PROPERTY = 6,
  FIGHTREQUEST = 7,
  FIGHTRESPONSE = 8,
  FIGHTING = 9,
  QTE = 10,
  ITEM = 11,
  HARDBEAT = 12,
  FIGHTRESULT = 13,
  PKTOP = 14,
  ROOM = 15,
  TIMEDELAY = 20,
  BILL = 21,
  MAIL = 22,
  MONEY = 23,
  GOLD = 24,
  ADDFRIENDLIST = 25,
  RANK = 26,
  FRIENDLIST = 27,
  RANKTOP = 28,
  VERSION = 29,
  LOGIN = 30
};
bool TYPE_IsValid(int value);
const TYPE TYPE_MIN = LOST;
const TYPE TYPE_MAX = HA;
const int TYPE_ARRAYSIZE = TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* TYPE_descriptor();
inline const ::std::string& TYPE_Name(TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    TYPE_descriptor(), value);
}
inline bool TYPE_Parse(
    const ::std::string& name, TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TYPE>(
    TYPE_descriptor(), name, value);
}
enum RESULT {
  WIN = 1,
  LOSE = 2,
  RUN = 3
};
bool RESULT_IsValid(int value);
const RESULT RESULT_MIN = WIN;
const RESULT RESULT_MAX = RUN;
const int RESULT_ARRAYSIZE = RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* RESULT_descriptor();
inline const ::std::string& RESULT_Name(RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    RESULT_descriptor(), value);
}
inline bool RESULT_Parse(
    const ::std::string& name, RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RESULT>(
    RESULT_descriptor(), name, value);
}
enum STAT {
  FIGHT = 1,
  BUSY = 2,
  IDLE = 3,
  BREAK = 4
};
bool STAT_IsValid(int value);
const STAT STAT_MIN = FIGHT;
const STAT STAT_MAX = BREAK;
const int STAT_ARRAYSIZE = STAT_MAX + 1;

const ::google::protobuf::EnumDescriptor* STAT_descriptor();
inline const ::std::string& STAT_Name(STAT value) {
  return ::google::protobuf::internal::NameOfEnum(
    STAT_descriptor(), value);
}
inline bool STAT_Parse(
    const ::std::string& name, STAT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<STAT>(
    STAT_descriptor(), name, value);
}
// ===================================================================

class File : public ::google::protobuf::Message {
 public:
  File();
  virtual ~File();
  
  File(const File& from);
  
  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const File& default_instance();
  
  void Swap(File* other);
  
  // implements Message ----------------------------------------------
  
  File* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  
  // required string content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  
  // required string md5sum = 3;
  inline bool has_md5sum() const;
  inline void clear_md5sum();
  static const int kMd5SumFieldNumber = 3;
  inline const ::std::string& md5sum() const;
  inline void set_md5sum(const ::std::string& value);
  inline void set_md5sum(const char* value);
  inline void set_md5sum(const char* value, size_t size);
  inline ::std::string* mutable_md5sum();
  inline ::std::string* release_md5sum();
  
  // required bool match = 4;
  inline bool has_match() const;
  inline void clear_match();
  static const int kMatchFieldNumber = 4;
  inline bool match() const;
  inline void set_match(bool value);
  
  // @@protoc_insertion_point(class_scope:PWRD.File)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_md5sum();
  inline void clear_has_md5sum();
  inline void set_has_match();
  inline void clear_has_match();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* path_;
  ::std::string* content_;
  ::std::string* md5sum_;
  bool match_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static File* default_instance_;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message {
 public:
  Status();
  virtual ~Status();
  
  Status(const Status& from);
  
  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();
  
  void Swap(Status* other);
  
  // implements Message ----------------------------------------------
  
  Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  
  // @@protoc_insertion_point(class_scope:PWRD.Status)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* path_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static Status* default_instance_;
};
// -------------------------------------------------------------------

class C2S_FileStatus : public ::google::protobuf::Message {
 public:
  C2S_FileStatus();
  virtual ~C2S_FileStatus();
  
  C2S_FileStatus(const C2S_FileStatus& from);
  
  inline C2S_FileStatus& operator=(const C2S_FileStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_FileStatus& default_instance();
  
  void Swap(C2S_FileStatus* other);
  
  // implements Message ----------------------------------------------
  
  C2S_FileStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_FileStatus& from);
  void MergeFrom(const C2S_FileStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool match = 1;
  inline bool has_match() const;
  inline void clear_match();
  static const int kMatchFieldNumber = 1;
  inline bool match() const;
  inline void set_match(bool value);
  
  // repeated .PWRD.Status stat = 2;
  inline int stat_size() const;
  inline void clear_stat();
  static const int kStatFieldNumber = 2;
  inline const ::PWRD::Status& stat(int index) const;
  inline ::PWRD::Status* mutable_stat(int index);
  inline ::PWRD::Status* add_stat();
  inline const ::google::protobuf::RepeatedPtrField< ::PWRD::Status >&
      stat() const;
  inline ::google::protobuf::RepeatedPtrField< ::PWRD::Status >*
      mutable_stat();
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_FileStatus)
 private:
  inline void set_has_match();
  inline void clear_has_match();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::PWRD::Status > stat_;
  bool match_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_FileStatus* default_instance_;
};
// -------------------------------------------------------------------

class S2C_FileList : public ::google::protobuf::Message {
 public:
  S2C_FileList();
  virtual ~S2C_FileList();
  
  S2C_FileList(const S2C_FileList& from);
  
  inline S2C_FileList& operator=(const S2C_FileList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_FileList& default_instance();
  
  void Swap(S2C_FileList* other);
  
  // implements Message ----------------------------------------------
  
  S2C_FileList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_FileList& from);
  void MergeFrom(const S2C_FileList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PWRD.File file = 1;
  inline int file_size() const;
  inline void clear_file();
  static const int kFileFieldNumber = 1;
  inline const ::PWRD::File& file(int index) const;
  inline ::PWRD::File* mutable_file(int index);
  inline ::PWRD::File* add_file();
  inline const ::google::protobuf::RepeatedPtrField< ::PWRD::File >&
      file() const;
  inline ::google::protobuf::RepeatedPtrField< ::PWRD::File >*
      mutable_file();
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_FileList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::PWRD::File > file_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_FileList* default_instance_;
};
// -------------------------------------------------------------------

class C2S_Version : public ::google::protobuf::Message {
 public:
  C2S_Version();
  virtual ~C2S_Version();
  
  C2S_Version(const C2S_Version& from);
  
  inline C2S_Version& operator=(const C2S_Version& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_Version& default_instance();
  
  void Swap(C2S_Version* other);
  
  // implements Message ----------------------------------------------
  
  C2S_Version* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_Version& from);
  void MergeFrom(const C2S_Version& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_Version)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_Version* default_instance_;
};
// -------------------------------------------------------------------

class S2C_Version : public ::google::protobuf::Message {
 public:
  S2C_Version();
  virtual ~S2C_Version();
  
  S2C_Version(const S2C_Version& from);
  
  inline S2C_Version& operator=(const S2C_Version& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_Version& default_instance();
  
  void Swap(S2C_Version* other);
  
  // implements Message ----------------------------------------------
  
  S2C_Version* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_Version& from);
  void MergeFrom(const S2C_Version& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool match = 1;
  inline bool has_match() const;
  inline void clear_match();
  static const int kMatchFieldNumber = 1;
  inline bool match() const;
  inline void set_match(bool value);
  
  // repeated .PWRD.File flist = 2;
  inline int flist_size() const;
  inline void clear_flist();
  static const int kFlistFieldNumber = 2;
  inline const ::PWRD::File& flist(int index) const;
  inline ::PWRD::File* mutable_flist(int index);
  inline ::PWRD::File* add_flist();
  inline const ::google::protobuf::RepeatedPtrField< ::PWRD::File >&
      flist() const;
  inline ::google::protobuf::RepeatedPtrField< ::PWRD::File >*
      mutable_flist();
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_Version)
 private:
  inline void set_has_match();
  inline void clear_has_match();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::PWRD::File > flist_;
  bool match_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_Version* default_instance_;
};
// -------------------------------------------------------------------

class C2S_Registe : public ::google::protobuf::Message {
 public:
  C2S_Registe();
  virtual ~C2S_Registe();
  
  C2S_Registe(const C2S_Registe& from);
  
  inline C2S_Registe& operator=(const C2S_Registe& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_Registe& default_instance();
  
  void Swap(C2S_Registe* other);
  
  // implements Message ----------------------------------------------
  
  C2S_Registe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_Registe& from);
  void MergeFrom(const C2S_Registe& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string rolename = 1;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRolenameFieldNumber = 1;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  
  // required string uuid = 2;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 2;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_Registe)
 private:
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rolename_;
  ::std::string* uuid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_Registe* default_instance_;
};
// -------------------------------------------------------------------

class S2C_Registe : public ::google::protobuf::Message {
 public:
  S2C_Registe();
  virtual ~S2C_Registe();
  
  S2C_Registe(const S2C_Registe& from);
  
  inline S2C_Registe& operator=(const S2C_Registe& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_Registe& default_instance();
  
  void Swap(S2C_Registe* other);
  
  // implements Message ----------------------------------------------
  
  S2C_Registe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_Registe& from);
  void MergeFrom(const S2C_Registe& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_Registe)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_Registe* default_instance_;
};
// -------------------------------------------------------------------

class C2S_Login : public ::google::protobuf::Message {
 public:
  C2S_Login();
  virtual ~C2S_Login();
  
  C2S_Login(const C2S_Login& from);
  
  inline C2S_Login& operator=(const C2S_Login& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_Login& default_instance();
  
  void Swap(C2S_Login* other);
  
  // implements Message ----------------------------------------------
  
  C2S_Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_Login& from);
  void MergeFrom(const C2S_Login& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_Login)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_Login* default_instance_;
};
// -------------------------------------------------------------------

class S2C_Login : public ::google::protobuf::Message {
 public:
  S2C_Login();
  virtual ~S2C_Login();
  
  S2C_Login(const S2C_Login& from);
  
  inline S2C_Login& operator=(const S2C_Login& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_Login& default_instance();
  
  void Swap(S2C_Login* other);
  
  // implements Message ----------------------------------------------
  
  S2C_Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_Login& from);
  void MergeFrom(const S2C_Login& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool ok = 1;
  inline bool has_ok() const;
  inline void clear_ok();
  static const int kOkFieldNumber = 1;
  inline bool ok() const;
  inline void set_ok(bool value);
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_Login)
 private:
  inline void set_has_ok();
  inline void clear_has_ok();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool ok_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_Login* default_instance_;
};
// -------------------------------------------------------------------

class C2S_Room : public ::google::protobuf::Message {
 public:
  C2S_Room();
  virtual ~C2S_Room();
  
  C2S_Room(const C2S_Room& from);
  
  inline C2S_Room& operator=(const C2S_Room& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_Room& default_instance();
  
  void Swap(C2S_Room* other);
  
  // implements Message ----------------------------------------------
  
  C2S_Room* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_Room& from);
  void MergeFrom(const C2S_Room& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_Room)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_Room* default_instance_;
};
// -------------------------------------------------------------------

class S2C_Room : public ::google::protobuf::Message {
 public:
  S2C_Room();
  virtual ~S2C_Room();
  
  S2C_Room(const S2C_Room& from);
  
  inline S2C_Room& operator=(const S2C_Room& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_Room& default_instance();
  
  void Swap(S2C_Room* other);
  
  // implements Message ----------------------------------------------
  
  S2C_Room* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_Room& from);
  void MergeFrom(const S2C_Room& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required int32 online = 2;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 2;
  inline ::google::protobuf::int32 online() const;
  inline void set_online(::google::protobuf::int32 value);
  
  // required string bulletin = 3;
  inline bool has_bulletin() const;
  inline void clear_bulletin();
  static const int kBulletinFieldNumber = 3;
  inline const ::std::string& bulletin() const;
  inline void set_bulletin(const ::std::string& value);
  inline void set_bulletin(const char* value);
  inline void set_bulletin(const char* value, size_t size);
  inline ::std::string* mutable_bulletin();
  inline ::std::string* release_bulletin();
  
  // required int32 mail = 4;
  inline bool has_mail() const;
  inline void clear_mail();
  static const int kMailFieldNumber = 4;
  inline ::google::protobuf::int32 mail() const;
  inline void set_mail(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_Room)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_online();
  inline void clear_has_online();
  inline void set_has_bulletin();
  inline void clear_has_bulletin();
  inline void set_has_mail();
  inline void clear_has_mail();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* bulletin_;
  ::google::protobuf::int32 online_;
  ::google::protobuf::int32 mail_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_Room* default_instance_;
};
// -------------------------------------------------------------------

class C2S_TimeStamp : public ::google::protobuf::Message {
 public:
  C2S_TimeStamp();
  virtual ~C2S_TimeStamp();
  
  C2S_TimeStamp(const C2S_TimeStamp& from);
  
  inline C2S_TimeStamp& operator=(const C2S_TimeStamp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_TimeStamp& default_instance();
  
  void Swap(C2S_TimeStamp* other);
  
  // implements Message ----------------------------------------------
  
  C2S_TimeStamp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_TimeStamp& from);
  void MergeFrom(const C2S_TimeStamp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_TimeStamp)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* timestamp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_TimeStamp* default_instance_;
};
// -------------------------------------------------------------------

class S2C_TimeStamp : public ::google::protobuf::Message {
 public:
  S2C_TimeStamp();
  virtual ~S2C_TimeStamp();
  
  S2C_TimeStamp(const S2C_TimeStamp& from);
  
  inline S2C_TimeStamp& operator=(const S2C_TimeStamp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_TimeStamp& default_instance();
  
  void Swap(S2C_TimeStamp* other);
  
  // implements Message ----------------------------------------------
  
  S2C_TimeStamp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_TimeStamp& from);
  void MergeFrom(const S2C_TimeStamp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_TimeStamp)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* timestamp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_TimeStamp* default_instance_;
};
// -------------------------------------------------------------------

class Equipment : public ::google::protobuf::Message {
 public:
  Equipment();
  virtual ~Equipment();
  
  Equipment(const Equipment& from);
  
  inline Equipment& operator=(const Equipment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Equipment& default_instance();
  
  void Swap(Equipment* other);
  
  // implements Message ----------------------------------------------
  
  Equipment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Equipment& from);
  void MergeFrom(const Equipment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string elist = 2;
  inline bool has_elist() const;
  inline void clear_elist();
  static const int kElistFieldNumber = 2;
  inline const ::std::string& elist() const;
  inline void set_elist(const ::std::string& value);
  inline void set_elist(const char* value);
  inline void set_elist(const char* value, size_t size);
  inline ::std::string* mutable_elist();
  inline ::std::string* release_elist();
  
  // @@protoc_insertion_point(class_scope:PWRD.Equipment)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_elist();
  inline void clear_has_elist();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* elist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static Equipment* default_instance_;
};
// -------------------------------------------------------------------

class C2S_Property : public ::google::protobuf::Message {
 public:
  C2S_Property();
  virtual ~C2S_Property();
  
  C2S_Property(const C2S_Property& from);
  
  inline C2S_Property& operator=(const C2S_Property& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_Property& default_instance();
  
  void Swap(C2S_Property* other);
  
  // implements Message ----------------------------------------------
  
  C2S_Property* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_Property& from);
  void MergeFrom(const C2S_Property& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_Property)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_Property* default_instance_;
};
// -------------------------------------------------------------------

class S2C_Property : public ::google::protobuf::Message {
 public:
  S2C_Property();
  virtual ~S2C_Property();
  
  S2C_Property(const S2C_Property& from);
  
  inline S2C_Property& operator=(const S2C_Property& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_Property& default_instance();
  
  void Swap(S2C_Property* other);
  
  // implements Message ----------------------------------------------
  
  S2C_Property* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_Property& from);
  void MergeFrom(const S2C_Property& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string rolename = 2;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRolenameFieldNumber = 2;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  
  // required int32 pklevel = 3;
  inline bool has_pklevel() const;
  inline void clear_pklevel();
  static const int kPklevelFieldNumber = 3;
  inline ::google::protobuf::int32 pklevel() const;
  inline void set_pklevel(::google::protobuf::int32 value);
  
  // required int32 pkexp = 4;
  inline bool has_pkexp() const;
  inline void clear_pkexp();
  static const int kPkexpFieldNumber = 4;
  inline ::google::protobuf::int32 pkexp() const;
  inline void set_pkexp(::google::protobuf::int32 value);
  
  // required int32 rankexp = 5;
  inline bool has_rankexp() const;
  inline void clear_rankexp();
  static const int kRankexpFieldNumber = 5;
  inline ::google::protobuf::int32 rankexp() const;
  inline void set_rankexp(::google::protobuf::int32 value);
  
  // required int32 ranklevel = 6;
  inline bool has_ranklevel() const;
  inline void clear_ranklevel();
  static const int kRanklevelFieldNumber = 6;
  inline ::google::protobuf::int32 ranklevel() const;
  inline void set_ranklevel(::google::protobuf::int32 value);
  
  // required int32 money = 7;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 7;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);
  
  // required int32 gold = 8;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 8;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);
  
  // required string items = 9;
  inline bool has_items() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 9;
  inline const ::std::string& items() const;
  inline void set_items(const ::std::string& value);
  inline void set_items(const char* value);
  inline void set_items(const char* value, size_t size);
  inline ::std::string* mutable_items();
  inline ::std::string* release_items();
  
  // required string equips = 10;
  inline bool has_equips() const;
  inline void clear_equips();
  static const int kEquipsFieldNumber = 10;
  inline const ::std::string& equips() const;
  inline void set_equips(const ::std::string& value);
  inline void set_equips(const char* value);
  inline void set_equips(const char* value, size_t size);
  inline ::std::string* mutable_equips();
  inline ::std::string* release_equips();
  
  // required string buffs = 11;
  inline bool has_buffs() const;
  inline void clear_buffs();
  static const int kBuffsFieldNumber = 11;
  inline const ::std::string& buffs() const;
  inline void set_buffs(const ::std::string& value);
  inline void set_buffs(const char* value);
  inline void set_buffs(const char* value, size_t size);
  inline ::std::string* mutable_buffs();
  inline ::std::string* release_buffs();
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_Property)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_pklevel();
  inline void clear_has_pklevel();
  inline void set_has_pkexp();
  inline void clear_has_pkexp();
  inline void set_has_rankexp();
  inline void clear_has_rankexp();
  inline void set_has_ranklevel();
  inline void clear_has_ranklevel();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_items();
  inline void clear_has_items();
  inline void set_has_equips();
  inline void clear_has_equips();
  inline void set_has_buffs();
  inline void clear_has_buffs();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* rolename_;
  ::google::protobuf::int32 pklevel_;
  ::google::protobuf::int32 pkexp_;
  ::google::protobuf::int32 rankexp_;
  ::google::protobuf::int32 ranklevel_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 gold_;
  ::std::string* items_;
  ::std::string* equips_;
  ::std::string* buffs_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_Property* default_instance_;
};
// -------------------------------------------------------------------

class PKProperty : public ::google::protobuf::Message {
 public:
  PKProperty();
  virtual ~PKProperty();
  
  PKProperty(const PKProperty& from);
  
  inline PKProperty& operator=(const PKProperty& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PKProperty& default_instance();
  
  void Swap(PKProperty* other);
  
  // implements Message ----------------------------------------------
  
  PKProperty* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PKProperty& from);
  void MergeFrom(const PKProperty& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string rolename = 2;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRolenameFieldNumber = 2;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  
  // required int32 pklevel = 3;
  inline bool has_pklevel() const;
  inline void clear_pklevel();
  static const int kPklevelFieldNumber = 3;
  inline ::google::protobuf::int32 pklevel() const;
  inline void set_pklevel(::google::protobuf::int32 value);
  
  // required int32 pkexp = 4;
  inline bool has_pkexp() const;
  inline void clear_pkexp();
  static const int kPkexpFieldNumber = 4;
  inline ::google::protobuf::int32 pkexp() const;
  inline void set_pkexp(::google::protobuf::int32 value);
  
  // required int32 ranklevel = 5;
  inline bool has_ranklevel() const;
  inline void clear_ranklevel();
  static const int kRanklevelFieldNumber = 5;
  inline ::google::protobuf::int32 ranklevel() const;
  inline void set_ranklevel(::google::protobuf::int32 value);
  
  // required int32 rankexp = 6;
  inline bool has_rankexp() const;
  inline void clear_rankexp();
  static const int kRankexpFieldNumber = 6;
  inline ::google::protobuf::int32 rankexp() const;
  inline void set_rankexp(::google::protobuf::int32 value);
  
  // required string items = 7;
  inline bool has_items() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 7;
  inline const ::std::string& items() const;
  inline void set_items(const ::std::string& value);
  inline void set_items(const char* value);
  inline void set_items(const char* value, size_t size);
  inline ::std::string* mutable_items();
  inline ::std::string* release_items();
  
  // required string equips = 8;
  inline bool has_equips() const;
  inline void clear_equips();
  static const int kEquipsFieldNumber = 8;
  inline const ::std::string& equips() const;
  inline void set_equips(const ::std::string& value);
  inline void set_equips(const char* value);
  inline void set_equips(const char* value, size_t size);
  inline ::std::string* mutable_equips();
  inline ::std::string* release_equips();
  
  // required string buffs = 9;
  inline bool has_buffs() const;
  inline void clear_buffs();
  static const int kBuffsFieldNumber = 9;
  inline const ::std::string& buffs() const;
  inline void set_buffs(const ::std::string& value);
  inline void set_buffs(const char* value);
  inline void set_buffs(const char* value, size_t size);
  inline ::std::string* mutable_buffs();
  inline ::std::string* release_buffs();
  
  // @@protoc_insertion_point(class_scope:PWRD.PKProperty)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_pklevel();
  inline void clear_has_pklevel();
  inline void set_has_pkexp();
  inline void clear_has_pkexp();
  inline void set_has_ranklevel();
  inline void clear_has_ranklevel();
  inline void set_has_rankexp();
  inline void clear_has_rankexp();
  inline void set_has_items();
  inline void clear_has_items();
  inline void set_has_equips();
  inline void clear_has_equips();
  inline void set_has_buffs();
  inline void clear_has_buffs();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* rolename_;
  ::google::protobuf::int32 pklevel_;
  ::google::protobuf::int32 pkexp_;
  ::google::protobuf::int32 ranklevel_;
  ::google::protobuf::int32 rankexp_;
  ::std::string* items_;
  ::std::string* equips_;
  ::std::string* buffs_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static PKProperty* default_instance_;
};
// -------------------------------------------------------------------

class C2S_PKList : public ::google::protobuf::Message {
 public:
  C2S_PKList();
  virtual ~C2S_PKList();
  
  C2S_PKList(const C2S_PKList& from);
  
  inline C2S_PKList& operator=(const C2S_PKList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_PKList& default_instance();
  
  void Swap(C2S_PKList* other);
  
  // implements Message ----------------------------------------------
  
  C2S_PKList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_PKList& from);
  void MergeFrom(const C2S_PKList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string request = 2;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 2;
  inline const ::std::string& request() const;
  inline void set_request(const ::std::string& value);
  inline void set_request(const char* value);
  inline void set_request(const char* value, size_t size);
  inline ::std::string* mutable_request();
  inline ::std::string* release_request();
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_PKList)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_request();
  inline void clear_has_request();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* request_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_PKList* default_instance_;
};
// -------------------------------------------------------------------

class PKTop : public ::google::protobuf::Message {
 public:
  PKTop();
  virtual ~PKTop();
  
  PKTop(const PKTop& from);
  
  inline PKTop& operator=(const PKTop& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PKTop& default_instance();
  
  void Swap(PKTop* other);
  
  // implements Message ----------------------------------------------
  
  PKTop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PKTop& from);
  void MergeFrom(const PKTop& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required int32 pkexp = 2;
  inline bool has_pkexp() const;
  inline void clear_pkexp();
  static const int kPkexpFieldNumber = 2;
  inline ::google::protobuf::int32 pkexp() const;
  inline void set_pkexp(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PWRD.PKTop)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_pkexp();
  inline void clear_has_pkexp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::google::protobuf::int32 pkexp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static PKTop* default_instance_;
};
// -------------------------------------------------------------------

class PKTopList : public ::google::protobuf::Message {
 public:
  PKTopList();
  virtual ~PKTopList();
  
  PKTopList(const PKTopList& from);
  
  inline PKTopList& operator=(const PKTopList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PKTopList& default_instance();
  
  void Swap(PKTopList* other);
  
  // implements Message ----------------------------------------------
  
  PKTopList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PKTopList& from);
  void MergeFrom(const PKTopList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PWRD.PKTop pktop = 1;
  inline int pktop_size() const;
  inline void clear_pktop();
  static const int kPktopFieldNumber = 1;
  inline const ::PWRD::PKTop& pktop(int index) const;
  inline ::PWRD::PKTop* mutable_pktop(int index);
  inline ::PWRD::PKTop* add_pktop();
  inline const ::google::protobuf::RepeatedPtrField< ::PWRD::PKTop >&
      pktop() const;
  inline ::google::protobuf::RepeatedPtrField< ::PWRD::PKTop >*
      mutable_pktop();
  
  // @@protoc_insertion_point(class_scope:PWRD.PKTopList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::PWRD::PKTop > pktop_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static PKTopList* default_instance_;
};
// -------------------------------------------------------------------

class C2S_Bill : public ::google::protobuf::Message {
 public:
  C2S_Bill();
  virtual ~C2S_Bill();
  
  C2S_Bill(const C2S_Bill& from);
  
  inline C2S_Bill& operator=(const C2S_Bill& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_Bill& default_instance();
  
  void Swap(C2S_Bill* other);
  
  // implements Message ----------------------------------------------
  
  C2S_Bill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_Bill& from);
  void MergeFrom(const C2S_Bill& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string itemid = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 2;
  inline const ::std::string& itemid() const;
  inline void set_itemid(const ::std::string& value);
  inline void set_itemid(const char* value);
  inline void set_itemid(const char* value, size_t size);
  inline ::std::string* mutable_itemid();
  inline ::std::string* release_itemid();
  
  // required int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_Bill)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_num();
  inline void clear_has_num();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* itemid_;
  ::google::protobuf::int32 num_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_Bill* default_instance_;
};
// -------------------------------------------------------------------

class S2C_Bill : public ::google::protobuf::Message {
 public:
  S2C_Bill();
  virtual ~S2C_Bill();
  
  S2C_Bill(const S2C_Bill& from);
  
  inline S2C_Bill& operator=(const S2C_Bill& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_Bill& default_instance();
  
  void Swap(S2C_Bill* other);
  
  // implements Message ----------------------------------------------
  
  S2C_Bill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_Bill& from);
  void MergeFrom(const S2C_Bill& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_Bill)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::google::protobuf::int32 status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_Bill* default_instance_;
};
// -------------------------------------------------------------------

class S2C_Gold : public ::google::protobuf::Message {
 public:
  S2C_Gold();
  virtual ~S2C_Gold();
  
  S2C_Gold(const S2C_Gold& from);
  
  inline S2C_Gold& operator=(const S2C_Gold& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_Gold& default_instance();
  
  void Swap(S2C_Gold* other);
  
  // implements Message ----------------------------------------------
  
  S2C_Gold* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_Gold& from);
  void MergeFrom(const S2C_Gold& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required int32 gold = 2;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 2;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_Gold)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_gold();
  inline void clear_has_gold();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::google::protobuf::int32 gold_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_Gold* default_instance_;
};
// -------------------------------------------------------------------

class C2S_Money : public ::google::protobuf::Message {
 public:
  C2S_Money();
  virtual ~C2S_Money();
  
  C2S_Money(const C2S_Money& from);
  
  inline C2S_Money& operator=(const C2S_Money& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_Money& default_instance();
  
  void Swap(C2S_Money* other);
  
  // implements Message ----------------------------------------------
  
  C2S_Money* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_Money& from);
  void MergeFrom(const C2S_Money& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required int32 money = 2;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 2;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_Money)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_money();
  inline void clear_has_money();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::google::protobuf::int32 money_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_Money* default_instance_;
};
// -------------------------------------------------------------------

class C2S_PKStat : public ::google::protobuf::Message {
 public:
  C2S_PKStat();
  virtual ~C2S_PKStat();
  
  C2S_PKStat(const C2S_PKStat& from);
  
  inline C2S_PKStat& operator=(const C2S_PKStat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_PKStat& default_instance();
  
  void Swap(C2S_PKStat* other);
  
  // implements Message ----------------------------------------------
  
  C2S_PKStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_PKStat& from);
  void MergeFrom(const C2S_PKStat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_PKStat)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_PKStat* default_instance_;
};
// -------------------------------------------------------------------

class S2C_PKStat : public ::google::protobuf::Message {
 public:
  S2C_PKStat();
  virtual ~S2C_PKStat();
  
  S2C_PKStat(const S2C_PKStat& from);
  
  inline S2C_PKStat& operator=(const S2C_PKStat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_PKStat& default_instance();
  
  void Swap(S2C_PKStat* other);
  
  // implements Message ----------------------------------------------
  
  S2C_PKStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_PKStat& from);
  void MergeFrom(const S2C_PKStat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required .PWRD.STAT stat = 2;
  inline bool has_stat() const;
  inline void clear_stat();
  static const int kStatFieldNumber = 2;
  inline PWRD::STAT stat() const;
  inline void set_stat(PWRD::STAT value);
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_PKStat)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_stat();
  inline void clear_has_stat();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  int stat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_PKStat* default_instance_;
};
// -------------------------------------------------------------------

class S2C_PKList : public ::google::protobuf::Message {
 public:
  S2C_PKList();
  virtual ~S2C_PKList();
  
  S2C_PKList(const S2C_PKList& from);
  
  inline S2C_PKList& operator=(const S2C_PKList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_PKList& default_instance();
  
  void Swap(S2C_PKList* other);
  
  // implements Message ----------------------------------------------
  
  S2C_PKList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_PKList& from);
  void MergeFrom(const S2C_PKList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PWRD.PKProperty pkpro = 1;
  inline int pkpro_size() const;
  inline void clear_pkpro();
  static const int kPkproFieldNumber = 1;
  inline const ::PWRD::PKProperty& pkpro(int index) const;
  inline ::PWRD::PKProperty* mutable_pkpro(int index);
  inline ::PWRD::PKProperty* add_pkpro();
  inline const ::google::protobuf::RepeatedPtrField< ::PWRD::PKProperty >&
      pkpro() const;
  inline ::google::protobuf::RepeatedPtrField< ::PWRD::PKProperty >*
      mutable_pkpro();
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_PKList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::PWRD::PKProperty > pkpro_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_PKList* default_instance_;
};
// -------------------------------------------------------------------

class C2S_FightRequest : public ::google::protobuf::Message {
 public:
  C2S_FightRequest();
  virtual ~C2S_FightRequest();
  
  C2S_FightRequest(const C2S_FightRequest& from);
  
  inline C2S_FightRequest& operator=(const C2S_FightRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_FightRequest& default_instance();
  
  void Swap(C2S_FightRequest* other);
  
  // implements Message ----------------------------------------------
  
  C2S_FightRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_FightRequest& from);
  void MergeFrom(const C2S_FightRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string froleid = 2;
  inline bool has_froleid() const;
  inline void clear_froleid();
  static const int kFroleidFieldNumber = 2;
  inline const ::std::string& froleid() const;
  inline void set_froleid(const ::std::string& value);
  inline void set_froleid(const char* value);
  inline void set_froleid(const char* value, size_t size);
  inline ::std::string* mutable_froleid();
  inline ::std::string* release_froleid();
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_FightRequest)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_froleid();
  inline void clear_has_froleid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* froleid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_FightRequest* default_instance_;
};
// -------------------------------------------------------------------

class S2C_FightRequest : public ::google::protobuf::Message {
 public:
  S2C_FightRequest();
  virtual ~S2C_FightRequest();
  
  S2C_FightRequest(const S2C_FightRequest& from);
  
  inline S2C_FightRequest& operator=(const S2C_FightRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_FightRequest& default_instance();
  
  void Swap(S2C_FightRequest* other);
  
  // implements Message ----------------------------------------------
  
  S2C_FightRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_FightRequest& from);
  void MergeFrom(const S2C_FightRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string froleid = 2;
  inline bool has_froleid() const;
  inline void clear_froleid();
  static const int kFroleidFieldNumber = 2;
  inline const ::std::string& froleid() const;
  inline void set_froleid(const ::std::string& value);
  inline void set_froleid(const char* value);
  inline void set_froleid(const char* value, size_t size);
  inline ::std::string* mutable_froleid();
  inline ::std::string* release_froleid();
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_FightRequest)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_froleid();
  inline void clear_has_froleid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* froleid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_FightRequest* default_instance_;
};
// -------------------------------------------------------------------

class C2S_FightResponse : public ::google::protobuf::Message {
 public:
  C2S_FightResponse();
  virtual ~C2S_FightResponse();
  
  C2S_FightResponse(const C2S_FightResponse& from);
  
  inline C2S_FightResponse& operator=(const C2S_FightResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_FightResponse& default_instance();
  
  void Swap(C2S_FightResponse* other);
  
  // implements Message ----------------------------------------------
  
  C2S_FightResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_FightResponse& from);
  void MergeFrom(const C2S_FightResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string froleid = 2;
  inline bool has_froleid() const;
  inline void clear_froleid();
  static const int kFroleidFieldNumber = 2;
  inline const ::std::string& froleid() const;
  inline void set_froleid(const ::std::string& value);
  inline void set_froleid(const char* value);
  inline void set_froleid(const char* value, size_t size);
  inline ::std::string* mutable_froleid();
  inline ::std::string* release_froleid();
  
  // required bool ido = 3;
  inline bool has_ido() const;
  inline void clear_ido();
  static const int kIdoFieldNumber = 3;
  inline bool ido() const;
  inline void set_ido(bool value);
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_FightResponse)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_froleid();
  inline void clear_has_froleid();
  inline void set_has_ido();
  inline void clear_has_ido();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* froleid_;
  bool ido_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_FightResponse* default_instance_;
};
// -------------------------------------------------------------------

class S2C_FightResponse : public ::google::protobuf::Message {
 public:
  S2C_FightResponse();
  virtual ~S2C_FightResponse();
  
  S2C_FightResponse(const S2C_FightResponse& from);
  
  inline S2C_FightResponse& operator=(const S2C_FightResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_FightResponse& default_instance();
  
  void Swap(S2C_FightResponse* other);
  
  // implements Message ----------------------------------------------
  
  S2C_FightResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_FightResponse& from);
  void MergeFrom(const S2C_FightResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string froleid = 2;
  inline bool has_froleid() const;
  inline void clear_froleid();
  static const int kFroleidFieldNumber = 2;
  inline const ::std::string& froleid() const;
  inline void set_froleid(const ::std::string& value);
  inline void set_froleid(const char* value);
  inline void set_froleid(const char* value, size_t size);
  inline ::std::string* mutable_froleid();
  inline ::std::string* release_froleid();
  
  // required bool ido = 3;
  inline bool has_ido() const;
  inline void clear_ido();
  static const int kIdoFieldNumber = 3;
  inline bool ido() const;
  inline void set_ido(bool value);
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_FightResponse)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_froleid();
  inline void clear_has_froleid();
  inline void set_has_ido();
  inline void clear_has_ido();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* froleid_;
  bool ido_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_FightResponse* default_instance_;
};
// -------------------------------------------------------------------

class Beat : public ::google::protobuf::Message {
 public:
  Beat();
  virtual ~Beat();
  
  Beat(const Beat& from);
  
  inline Beat& operator=(const Beat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Beat& default_instance();
  
  void Swap(Beat* other);
  
  // implements Message ----------------------------------------------
  
  Beat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Beat& from);
  void MergeFrom(const Beat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 hp = 1;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 1;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);
  
  // required string animation = 2;
  inline bool has_animation() const;
  inline void clear_animation();
  static const int kAnimationFieldNumber = 2;
  inline const ::std::string& animation() const;
  inline void set_animation(const ::std::string& value);
  inline void set_animation(const char* value);
  inline void set_animation(const char* value, size_t size);
  inline ::std::string* mutable_animation();
  inline ::std::string* release_animation();
  
  // @@protoc_insertion_point(class_scope:PWRD.Beat)
 private:
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_animation();
  inline void clear_has_animation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* animation_;
  ::google::protobuf::int32 hp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static Beat* default_instance_;
};
// -------------------------------------------------------------------

class C2S_Fight : public ::google::protobuf::Message {
 public:
  C2S_Fight();
  virtual ~C2S_Fight();
  
  C2S_Fight(const C2S_Fight& from);
  
  inline C2S_Fight& operator=(const C2S_Fight& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_Fight& default_instance();
  
  void Swap(C2S_Fight* other);
  
  // implements Message ----------------------------------------------
  
  C2S_Fight* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_Fight& from);
  void MergeFrom(const C2S_Fight& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string froleid = 2;
  inline bool has_froleid() const;
  inline void clear_froleid();
  static const int kFroleidFieldNumber = 2;
  inline const ::std::string& froleid() const;
  inline void set_froleid(const ::std::string& value);
  inline void set_froleid(const char* value);
  inline void set_froleid(const char* value, size_t size);
  inline ::std::string* mutable_froleid();
  inline ::std::string* release_froleid();
  
  // required .PWRD.Beat beat = 3;
  inline bool has_beat() const;
  inline void clear_beat();
  static const int kBeatFieldNumber = 3;
  inline const ::PWRD::Beat& beat() const;
  inline ::PWRD::Beat* mutable_beat();
  inline ::PWRD::Beat* release_beat();
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_Fight)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_froleid();
  inline void clear_has_froleid();
  inline void set_has_beat();
  inline void clear_has_beat();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* froleid_;
  ::PWRD::Beat* beat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_Fight* default_instance_;
};
// -------------------------------------------------------------------

class S2C_Fight : public ::google::protobuf::Message {
 public:
  S2C_Fight();
  virtual ~S2C_Fight();
  
  S2C_Fight(const S2C_Fight& from);
  
  inline S2C_Fight& operator=(const S2C_Fight& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_Fight& default_instance();
  
  void Swap(S2C_Fight* other);
  
  // implements Message ----------------------------------------------
  
  S2C_Fight* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_Fight& from);
  void MergeFrom(const S2C_Fight& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string froleid = 2;
  inline bool has_froleid() const;
  inline void clear_froleid();
  static const int kFroleidFieldNumber = 2;
  inline const ::std::string& froleid() const;
  inline void set_froleid(const ::std::string& value);
  inline void set_froleid(const char* value);
  inline void set_froleid(const char* value, size_t size);
  inline ::std::string* mutable_froleid();
  inline ::std::string* release_froleid();
  
  // required .PWRD.Beat beat = 3;
  inline bool has_beat() const;
  inline void clear_beat();
  static const int kBeatFieldNumber = 3;
  inline const ::PWRD::Beat& beat() const;
  inline ::PWRD::Beat* mutable_beat();
  inline ::PWRD::Beat* release_beat();
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_Fight)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_froleid();
  inline void clear_has_froleid();
  inline void set_has_beat();
  inline void clear_has_beat();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* froleid_;
  ::PWRD::Beat* beat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_Fight* default_instance_;
};
// -------------------------------------------------------------------

class C2S_HardBeat : public ::google::protobuf::Message {
 public:
  C2S_HardBeat();
  virtual ~C2S_HardBeat();
  
  C2S_HardBeat(const C2S_HardBeat& from);
  
  inline C2S_HardBeat& operator=(const C2S_HardBeat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_HardBeat& default_instance();
  
  void Swap(C2S_HardBeat* other);
  
  // implements Message ----------------------------------------------
  
  C2S_HardBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_HardBeat& from);
  void MergeFrom(const C2S_HardBeat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string froleid = 2;
  inline bool has_froleid() const;
  inline void clear_froleid();
  static const int kFroleidFieldNumber = 2;
  inline const ::std::string& froleid() const;
  inline void set_froleid(const ::std::string& value);
  inline void set_froleid(const char* value);
  inline void set_froleid(const char* value, size_t size);
  inline ::std::string* mutable_froleid();
  inline ::std::string* release_froleid();
  
  // required .PWRD.Beat beat = 3;
  inline bool has_beat() const;
  inline void clear_beat();
  static const int kBeatFieldNumber = 3;
  inline const ::PWRD::Beat& beat() const;
  inline ::PWRD::Beat* mutable_beat();
  inline ::PWRD::Beat* release_beat();
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_HardBeat)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_froleid();
  inline void clear_has_froleid();
  inline void set_has_beat();
  inline void clear_has_beat();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* froleid_;
  ::PWRD::Beat* beat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_HardBeat* default_instance_;
};
// -------------------------------------------------------------------

class S2C_HardBeat : public ::google::protobuf::Message {
 public:
  S2C_HardBeat();
  virtual ~S2C_HardBeat();
  
  S2C_HardBeat(const S2C_HardBeat& from);
  
  inline S2C_HardBeat& operator=(const S2C_HardBeat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_HardBeat& default_instance();
  
  void Swap(S2C_HardBeat* other);
  
  // implements Message ----------------------------------------------
  
  S2C_HardBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_HardBeat& from);
  void MergeFrom(const S2C_HardBeat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string froleid = 2;
  inline bool has_froleid() const;
  inline void clear_froleid();
  static const int kFroleidFieldNumber = 2;
  inline const ::std::string& froleid() const;
  inline void set_froleid(const ::std::string& value);
  inline void set_froleid(const char* value);
  inline void set_froleid(const char* value, size_t size);
  inline ::std::string* mutable_froleid();
  inline ::std::string* release_froleid();
  
  // required .PWRD.Beat beat = 3;
  inline bool has_beat() const;
  inline void clear_beat();
  static const int kBeatFieldNumber = 3;
  inline const ::PWRD::Beat& beat() const;
  inline ::PWRD::Beat* mutable_beat();
  inline ::PWRD::Beat* release_beat();
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_HardBeat)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_froleid();
  inline void clear_has_froleid();
  inline void set_has_beat();
  inline void clear_has_beat();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* froleid_;
  ::PWRD::Beat* beat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_HardBeat* default_instance_;
};
// -------------------------------------------------------------------

class QTE_Beat : public ::google::protobuf::Message {
 public:
  QTE_Beat();
  virtual ~QTE_Beat();
  
  QTE_Beat(const QTE_Beat& from);
  
  inline QTE_Beat& operator=(const QTE_Beat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const QTE_Beat& default_instance();
  
  void Swap(QTE_Beat* other);
  
  // implements Message ----------------------------------------------
  
  QTE_Beat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QTE_Beat& from);
  void MergeFrom(const QTE_Beat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 hp = 1;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 1;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);
  
  // required int32 during = 2;
  inline bool has_during() const;
  inline void clear_during();
  static const int kDuringFieldNumber = 2;
  inline ::google::protobuf::int32 during() const;
  inline void set_during(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PWRD.QTE_Beat)
 private:
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_during();
  inline void clear_has_during();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 during_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static QTE_Beat* default_instance_;
};
// -------------------------------------------------------------------

class C2S_QTE : public ::google::protobuf::Message {
 public:
  C2S_QTE();
  virtual ~C2S_QTE();
  
  C2S_QTE(const C2S_QTE& from);
  
  inline C2S_QTE& operator=(const C2S_QTE& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_QTE& default_instance();
  
  void Swap(C2S_QTE* other);
  
  // implements Message ----------------------------------------------
  
  C2S_QTE* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_QTE& from);
  void MergeFrom(const C2S_QTE& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string froleid = 2;
  inline bool has_froleid() const;
  inline void clear_froleid();
  static const int kFroleidFieldNumber = 2;
  inline const ::std::string& froleid() const;
  inline void set_froleid(const ::std::string& value);
  inline void set_froleid(const char* value);
  inline void set_froleid(const char* value, size_t size);
  inline ::std::string* mutable_froleid();
  inline ::std::string* release_froleid();
  
  // repeated .PWRD.QTE_Beat qte = 3;
  inline int qte_size() const;
  inline void clear_qte();
  static const int kQteFieldNumber = 3;
  inline const ::PWRD::QTE_Beat& qte(int index) const;
  inline ::PWRD::QTE_Beat* mutable_qte(int index);
  inline ::PWRD::QTE_Beat* add_qte();
  inline const ::google::protobuf::RepeatedPtrField< ::PWRD::QTE_Beat >&
      qte() const;
  inline ::google::protobuf::RepeatedPtrField< ::PWRD::QTE_Beat >*
      mutable_qte();
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_QTE)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_froleid();
  inline void clear_has_froleid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* froleid_;
  ::google::protobuf::RepeatedPtrField< ::PWRD::QTE_Beat > qte_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_QTE* default_instance_;
};
// -------------------------------------------------------------------

class S2C_QTE : public ::google::protobuf::Message {
 public:
  S2C_QTE();
  virtual ~S2C_QTE();
  
  S2C_QTE(const S2C_QTE& from);
  
  inline S2C_QTE& operator=(const S2C_QTE& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_QTE& default_instance();
  
  void Swap(S2C_QTE* other);
  
  // implements Message ----------------------------------------------
  
  S2C_QTE* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_QTE& from);
  void MergeFrom(const S2C_QTE& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string froleid = 2;
  inline bool has_froleid() const;
  inline void clear_froleid();
  static const int kFroleidFieldNumber = 2;
  inline const ::std::string& froleid() const;
  inline void set_froleid(const ::std::string& value);
  inline void set_froleid(const char* value);
  inline void set_froleid(const char* value, size_t size);
  inline ::std::string* mutable_froleid();
  inline ::std::string* release_froleid();
  
  // repeated .PWRD.QTE_Beat qte = 3;
  inline int qte_size() const;
  inline void clear_qte();
  static const int kQteFieldNumber = 3;
  inline const ::PWRD::QTE_Beat& qte(int index) const;
  inline ::PWRD::QTE_Beat* mutable_qte(int index);
  inline ::PWRD::QTE_Beat* add_qte();
  inline const ::google::protobuf::RepeatedPtrField< ::PWRD::QTE_Beat >&
      qte() const;
  inline ::google::protobuf::RepeatedPtrField< ::PWRD::QTE_Beat >*
      mutable_qte();
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_QTE)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_froleid();
  inline void clear_has_froleid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* froleid_;
  ::google::protobuf::RepeatedPtrField< ::PWRD::QTE_Beat > qte_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_QTE* default_instance_;
};
// -------------------------------------------------------------------

class C2S_Item : public ::google::protobuf::Message {
 public:
  C2S_Item();
  virtual ~C2S_Item();
  
  C2S_Item(const C2S_Item& from);
  
  inline C2S_Item& operator=(const C2S_Item& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_Item& default_instance();
  
  void Swap(C2S_Item* other);
  
  // implements Message ----------------------------------------------
  
  C2S_Item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_Item& from);
  void MergeFrom(const C2S_Item& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string froleid = 2;
  inline bool has_froleid() const;
  inline void clear_froleid();
  static const int kFroleidFieldNumber = 2;
  inline const ::std::string& froleid() const;
  inline void set_froleid(const ::std::string& value);
  inline void set_froleid(const char* value);
  inline void set_froleid(const char* value, size_t size);
  inline ::std::string* mutable_froleid();
  inline ::std::string* release_froleid();
  
  // required string itemid = 3;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 3;
  inline const ::std::string& itemid() const;
  inline void set_itemid(const ::std::string& value);
  inline void set_itemid(const char* value);
  inline void set_itemid(const char* value, size_t size);
  inline ::std::string* mutable_itemid();
  inline ::std::string* release_itemid();
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_Item)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_froleid();
  inline void clear_has_froleid();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* froleid_;
  ::std::string* itemid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_Item* default_instance_;
};
// -------------------------------------------------------------------

class S2C_Item : public ::google::protobuf::Message {
 public:
  S2C_Item();
  virtual ~S2C_Item();
  
  S2C_Item(const S2C_Item& from);
  
  inline S2C_Item& operator=(const S2C_Item& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_Item& default_instance();
  
  void Swap(S2C_Item* other);
  
  // implements Message ----------------------------------------------
  
  S2C_Item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_Item& from);
  void MergeFrom(const S2C_Item& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string froleid = 2;
  inline bool has_froleid() const;
  inline void clear_froleid();
  static const int kFroleidFieldNumber = 2;
  inline const ::std::string& froleid() const;
  inline void set_froleid(const ::std::string& value);
  inline void set_froleid(const char* value);
  inline void set_froleid(const char* value, size_t size);
  inline ::std::string* mutable_froleid();
  inline ::std::string* release_froleid();
  
  // required string itemid = 3;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 3;
  inline const ::std::string& itemid() const;
  inline void set_itemid(const ::std::string& value);
  inline void set_itemid(const char* value);
  inline void set_itemid(const char* value, size_t size);
  inline ::std::string* mutable_itemid();
  inline ::std::string* release_itemid();
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_Item)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_froleid();
  inline void clear_has_froleid();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* froleid_;
  ::std::string* itemid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_Item* default_instance_;
};
// -------------------------------------------------------------------

class S2C_FightResult : public ::google::protobuf::Message {
 public:
  S2C_FightResult();
  virtual ~S2C_FightResult();
  
  S2C_FightResult(const S2C_FightResult& from);
  
  inline S2C_FightResult& operator=(const S2C_FightResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_FightResult& default_instance();
  
  void Swap(S2C_FightResult* other);
  
  // implements Message ----------------------------------------------
  
  S2C_FightResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_FightResult& from);
  void MergeFrom(const S2C_FightResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string froleid = 2;
  inline bool has_froleid() const;
  inline void clear_froleid();
  static const int kFroleidFieldNumber = 2;
  inline const ::std::string& froleid() const;
  inline void set_froleid(const ::std::string& value);
  inline void set_froleid(const char* value);
  inline void set_froleid(const char* value, size_t size);
  inline ::std::string* mutable_froleid();
  inline ::std::string* release_froleid();
  
  // required int32 win = 4;
  inline bool has_win() const;
  inline void clear_win();
  static const int kWinFieldNumber = 4;
  inline ::google::protobuf::int32 win() const;
  inline void set_win(::google::protobuf::int32 value);
  
  // required int32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required string equipment = 10;
  inline bool has_equipment() const;
  inline void clear_equipment();
  static const int kEquipmentFieldNumber = 10;
  inline const ::std::string& equipment() const;
  inline void set_equipment(const ::std::string& value);
  inline void set_equipment(const char* value);
  inline void set_equipment(const char* value, size_t size);
  inline ::std::string* mutable_equipment();
  inline ::std::string* release_equipment();
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_FightResult)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_froleid();
  inline void clear_has_froleid();
  inline void set_has_win();
  inline void clear_has_win();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_equipment();
  inline void clear_has_equipment();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* froleid_;
  ::google::protobuf::int32 win_;
  ::google::protobuf::int32 type_;
  ::std::string* equipment_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_FightResult* default_instance_;
};
// -------------------------------------------------------------------

class C2S_FightResult : public ::google::protobuf::Message {
 public:
  C2S_FightResult();
  virtual ~C2S_FightResult();
  
  C2S_FightResult(const C2S_FightResult& from);
  
  inline C2S_FightResult& operator=(const C2S_FightResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_FightResult& default_instance();
  
  void Swap(C2S_FightResult* other);
  
  // implements Message ----------------------------------------------
  
  C2S_FightResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_FightResult& from);
  void MergeFrom(const C2S_FightResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string froleid = 2;
  inline bool has_froleid() const;
  inline void clear_froleid();
  static const int kFroleidFieldNumber = 2;
  inline const ::std::string& froleid() const;
  inline void set_froleid(const ::std::string& value);
  inline void set_froleid(const char* value);
  inline void set_froleid(const char* value, size_t size);
  inline ::std::string* mutable_froleid();
  inline ::std::string* release_froleid();
  
  // required int32 win = 4;
  inline bool has_win() const;
  inline void clear_win();
  static const int kWinFieldNumber = 4;
  inline ::google::protobuf::int32 win() const;
  inline void set_win(::google::protobuf::int32 value);
  
  // required int32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required string equipment = 10;
  inline bool has_equipment() const;
  inline void clear_equipment();
  static const int kEquipmentFieldNumber = 10;
  inline const ::std::string& equipment() const;
  inline void set_equipment(const ::std::string& value);
  inline void set_equipment(const char* value);
  inline void set_equipment(const char* value, size_t size);
  inline ::std::string* mutable_equipment();
  inline ::std::string* release_equipment();
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_FightResult)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_froleid();
  inline void clear_has_froleid();
  inline void set_has_win();
  inline void clear_has_win();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_equipment();
  inline void clear_has_equipment();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* froleid_;
  ::google::protobuf::int32 win_;
  ::google::protobuf::int32 type_;
  ::std::string* equipment_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_FightResult* default_instance_;
};
// -------------------------------------------------------------------

class C2S_Friend : public ::google::protobuf::Message {
 public:
  C2S_Friend();
  virtual ~C2S_Friend();
  
  C2S_Friend(const C2S_Friend& from);
  
  inline C2S_Friend& operator=(const C2S_Friend& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_Friend& default_instance();
  
  void Swap(C2S_Friend* other);
  
  // implements Message ----------------------------------------------
  
  C2S_Friend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_Friend& from);
  void MergeFrom(const C2S_Friend& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // optional int32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);
  
  // optional int32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);
  
  // optional int32 length = 4;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 4;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_Friend)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_length();
  inline void clear_has_length();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 length_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_Friend* default_instance_;
};
// -------------------------------------------------------------------

class S2C_Friend : public ::google::protobuf::Message {
 public:
  S2C_Friend();
  virtual ~S2C_Friend();
  
  S2C_Friend(const S2C_Friend& from);
  
  inline S2C_Friend& operator=(const S2C_Friend& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_Friend& default_instance();
  
  void Swap(S2C_Friend* other);
  
  // implements Message ----------------------------------------------
  
  S2C_Friend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_Friend& from);
  void MergeFrom(const S2C_Friend& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string flist = 2;
  inline bool has_flist() const;
  inline void clear_flist();
  static const int kFlistFieldNumber = 2;
  inline const ::std::string& flist() const;
  inline void set_flist(const ::std::string& value);
  inline void set_flist(const char* value);
  inline void set_flist(const char* value, size_t size);
  inline ::std::string* mutable_flist();
  inline ::std::string* release_flist();
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_Friend)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_flist();
  inline void clear_has_flist();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* flist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_Friend* default_instance_;
};
// -------------------------------------------------------------------

class C2S_AddFriend : public ::google::protobuf::Message {
 public:
  C2S_AddFriend();
  virtual ~C2S_AddFriend();
  
  C2S_AddFriend(const C2S_AddFriend& from);
  
  inline C2S_AddFriend& operator=(const C2S_AddFriend& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const C2S_AddFriend& default_instance();
  
  void Swap(C2S_AddFriend* other);
  
  // implements Message ----------------------------------------------
  
  C2S_AddFriend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2S_AddFriend& from);
  void MergeFrom(const C2S_AddFriend& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string flist = 2;
  inline bool has_flist() const;
  inline void clear_flist();
  static const int kFlistFieldNumber = 2;
  inline const ::std::string& flist() const;
  inline void set_flist(const ::std::string& value);
  inline void set_flist(const char* value);
  inline void set_flist(const char* value, size_t size);
  inline ::std::string* mutable_flist();
  inline ::std::string* release_flist();
  
  // @@protoc_insertion_point(class_scope:PWRD.C2S_AddFriend)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_flist();
  inline void clear_has_flist();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* flist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static C2S_AddFriend* default_instance_;
};
// -------------------------------------------------------------------

class S2C_AddFriend : public ::google::protobuf::Message {
 public:
  S2C_AddFriend();
  virtual ~S2C_AddFriend();
  
  S2C_AddFriend(const S2C_AddFriend& from);
  
  inline S2C_AddFriend& operator=(const S2C_AddFriend& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const S2C_AddFriend& default_instance();
  
  void Swap(S2C_AddFriend* other);
  
  // implements Message ----------------------------------------------
  
  S2C_AddFriend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2C_AddFriend& from);
  void MergeFrom(const S2C_AddFriend& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline const ::std::string& roleid() const;
  inline void set_roleid(const ::std::string& value);
  inline void set_roleid(const char* value);
  inline void set_roleid(const char* value, size_t size);
  inline ::std::string* mutable_roleid();
  inline ::std::string* release_roleid();
  
  // required string flist = 2;
  inline bool has_flist() const;
  inline void clear_flist();
  static const int kFlistFieldNumber = 2;
  inline const ::std::string& flist() const;
  inline void set_flist(const ::std::string& value);
  inline void set_flist(const char* value);
  inline void set_flist(const char* value, size_t size);
  inline ::std::string* mutable_flist();
  inline ::std::string* release_flist();
  
  // @@protoc_insertion_point(class_scope:PWRD.S2C_AddFriend)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_flist();
  inline void clear_has_flist();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* roleid_;
  ::std::string* flist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FightClub_2eproto();
  friend void protobuf_AssignDesc_FightClub_2eproto();
  friend void protobuf_ShutdownFile_FightClub_2eproto();
  
  void InitAsDefaultInstance();
  static S2C_AddFriend* default_instance_;
};
// ===================================================================


// ===================================================================

// File

// required string path = 1;
inline bool File::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void File::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void File::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void File::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& File::path() const {
  return *path_;
}
inline void File::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void File::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void File::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* File::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string content = 2;
inline bool File::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void File::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void File::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void File::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& File::content() const {
  return *content_;
}
inline void File::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void File::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void File::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* File::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string md5sum = 3;
inline bool File::has_md5sum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void File::set_has_md5sum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void File::clear_has_md5sum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void File::clear_md5sum() {
  if (md5sum_ != &::google::protobuf::internal::kEmptyString) {
    md5sum_->clear();
  }
  clear_has_md5sum();
}
inline const ::std::string& File::md5sum() const {
  return *md5sum_;
}
inline void File::set_md5sum(const ::std::string& value) {
  set_has_md5sum();
  if (md5sum_ == &::google::protobuf::internal::kEmptyString) {
    md5sum_ = new ::std::string;
  }
  md5sum_->assign(value);
}
inline void File::set_md5sum(const char* value) {
  set_has_md5sum();
  if (md5sum_ == &::google::protobuf::internal::kEmptyString) {
    md5sum_ = new ::std::string;
  }
  md5sum_->assign(value);
}
inline void File::set_md5sum(const char* value, size_t size) {
  set_has_md5sum();
  if (md5sum_ == &::google::protobuf::internal::kEmptyString) {
    md5sum_ = new ::std::string;
  }
  md5sum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* File::mutable_md5sum() {
  set_has_md5sum();
  if (md5sum_ == &::google::protobuf::internal::kEmptyString) {
    md5sum_ = new ::std::string;
  }
  return md5sum_;
}
inline ::std::string* File::release_md5sum() {
  clear_has_md5sum();
  if (md5sum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = md5sum_;
    md5sum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool match = 4;
inline bool File::has_match() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void File::set_has_match() {
  _has_bits_[0] |= 0x00000008u;
}
inline void File::clear_has_match() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void File::clear_match() {
  match_ = false;
  clear_has_match();
}
inline bool File::match() const {
  return match_;
}
inline void File::set_match(bool value) {
  set_has_match();
  match_ = value;
}

// -------------------------------------------------------------------

// Status

// required string path = 1;
inline bool Status::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Status::path() const {
  return *path_;
}
inline void Status::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void Status::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void Status::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Status::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* Status::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// C2S_FileStatus

// required bool match = 1;
inline bool C2S_FileStatus::has_match() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_FileStatus::set_has_match() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_FileStatus::clear_has_match() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_FileStatus::clear_match() {
  match_ = false;
  clear_has_match();
}
inline bool C2S_FileStatus::match() const {
  return match_;
}
inline void C2S_FileStatus::set_match(bool value) {
  set_has_match();
  match_ = value;
}

// repeated .PWRD.Status stat = 2;
inline int C2S_FileStatus::stat_size() const {
  return stat_.size();
}
inline void C2S_FileStatus::clear_stat() {
  stat_.Clear();
}
inline const ::PWRD::Status& C2S_FileStatus::stat(int index) const {
  return stat_.Get(index);
}
inline ::PWRD::Status* C2S_FileStatus::mutable_stat(int index) {
  return stat_.Mutable(index);
}
inline ::PWRD::Status* C2S_FileStatus::add_stat() {
  return stat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PWRD::Status >&
C2S_FileStatus::stat() const {
  return stat_;
}
inline ::google::protobuf::RepeatedPtrField< ::PWRD::Status >*
C2S_FileStatus::mutable_stat() {
  return &stat_;
}

// -------------------------------------------------------------------

// S2C_FileList

// repeated .PWRD.File file = 1;
inline int S2C_FileList::file_size() const {
  return file_.size();
}
inline void S2C_FileList::clear_file() {
  file_.Clear();
}
inline const ::PWRD::File& S2C_FileList::file(int index) const {
  return file_.Get(index);
}
inline ::PWRD::File* S2C_FileList::mutable_file(int index) {
  return file_.Mutable(index);
}
inline ::PWRD::File* S2C_FileList::add_file() {
  return file_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PWRD::File >&
S2C_FileList::file() const {
  return file_;
}
inline ::google::protobuf::RepeatedPtrField< ::PWRD::File >*
S2C_FileList::mutable_file() {
  return &file_;
}

// -------------------------------------------------------------------

// C2S_Version

// required string version = 1;
inline bool C2S_Version::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_Version::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_Version::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_Version::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& C2S_Version::version() const {
  return *version_;
}
inline void C2S_Version::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void C2S_Version::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void C2S_Version::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_Version::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* C2S_Version::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// S2C_Version

// required bool match = 1;
inline bool S2C_Version::has_match() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_Version::set_has_match() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_Version::clear_has_match() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_Version::clear_match() {
  match_ = false;
  clear_has_match();
}
inline bool S2C_Version::match() const {
  return match_;
}
inline void S2C_Version::set_match(bool value) {
  set_has_match();
  match_ = value;
}

// repeated .PWRD.File flist = 2;
inline int S2C_Version::flist_size() const {
  return flist_.size();
}
inline void S2C_Version::clear_flist() {
  flist_.Clear();
}
inline const ::PWRD::File& S2C_Version::flist(int index) const {
  return flist_.Get(index);
}
inline ::PWRD::File* S2C_Version::mutable_flist(int index) {
  return flist_.Mutable(index);
}
inline ::PWRD::File* S2C_Version::add_flist() {
  return flist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PWRD::File >&
S2C_Version::flist() const {
  return flist_;
}
inline ::google::protobuf::RepeatedPtrField< ::PWRD::File >*
S2C_Version::mutable_flist() {
  return &flist_;
}

// -------------------------------------------------------------------

// C2S_Registe

// required string rolename = 1;
inline bool C2S_Registe::has_rolename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_Registe::set_has_rolename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_Registe::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_Registe::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& C2S_Registe::rolename() const {
  return *rolename_;
}
inline void C2S_Registe::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void C2S_Registe::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void C2S_Registe::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_Registe::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* C2S_Registe::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string uuid = 2;
inline bool C2S_Registe::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2S_Registe::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2S_Registe::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2S_Registe::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& C2S_Registe::uuid() const {
  return *uuid_;
}
inline void C2S_Registe::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void C2S_Registe::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void C2S_Registe::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_Registe::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* C2S_Registe::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// S2C_Registe

// required string roleid = 1;
inline bool S2C_Registe::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_Registe::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_Registe::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_Registe::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& S2C_Registe::roleid() const {
  return *roleid_;
}
inline void S2C_Registe::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_Registe::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_Registe::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_Registe::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* S2C_Registe::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// C2S_Login

// required string roleid = 1;
inline bool C2S_Login::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_Login::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_Login::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_Login::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& C2S_Login::roleid() const {
  return *roleid_;
}
inline void C2S_Login::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_Login::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_Login::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_Login::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* C2S_Login::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// S2C_Login

// required bool ok = 1;
inline bool S2C_Login::has_ok() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_Login::set_has_ok() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_Login::clear_has_ok() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_Login::clear_ok() {
  ok_ = false;
  clear_has_ok();
}
inline bool S2C_Login::ok() const {
  return ok_;
}
inline void S2C_Login::set_ok(bool value) {
  set_has_ok();
  ok_ = value;
}

// -------------------------------------------------------------------

// C2S_Room

// required string roleid = 1;
inline bool C2S_Room::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_Room::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_Room::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_Room::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& C2S_Room::roleid() const {
  return *roleid_;
}
inline void C2S_Room::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_Room::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_Room::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_Room::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* C2S_Room::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// S2C_Room

// required string roleid = 1;
inline bool S2C_Room::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_Room::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_Room::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_Room::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& S2C_Room::roleid() const {
  return *roleid_;
}
inline void S2C_Room::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_Room::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_Room::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_Room::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* S2C_Room::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 online = 2;
inline bool S2C_Room::has_online() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2C_Room::set_has_online() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2C_Room::clear_has_online() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2C_Room::clear_online() {
  online_ = 0;
  clear_has_online();
}
inline ::google::protobuf::int32 S2C_Room::online() const {
  return online_;
}
inline void S2C_Room::set_online(::google::protobuf::int32 value) {
  set_has_online();
  online_ = value;
}

// required string bulletin = 3;
inline bool S2C_Room::has_bulletin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void S2C_Room::set_has_bulletin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void S2C_Room::clear_has_bulletin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void S2C_Room::clear_bulletin() {
  if (bulletin_ != &::google::protobuf::internal::kEmptyString) {
    bulletin_->clear();
  }
  clear_has_bulletin();
}
inline const ::std::string& S2C_Room::bulletin() const {
  return *bulletin_;
}
inline void S2C_Room::set_bulletin(const ::std::string& value) {
  set_has_bulletin();
  if (bulletin_ == &::google::protobuf::internal::kEmptyString) {
    bulletin_ = new ::std::string;
  }
  bulletin_->assign(value);
}
inline void S2C_Room::set_bulletin(const char* value) {
  set_has_bulletin();
  if (bulletin_ == &::google::protobuf::internal::kEmptyString) {
    bulletin_ = new ::std::string;
  }
  bulletin_->assign(value);
}
inline void S2C_Room::set_bulletin(const char* value, size_t size) {
  set_has_bulletin();
  if (bulletin_ == &::google::protobuf::internal::kEmptyString) {
    bulletin_ = new ::std::string;
  }
  bulletin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_Room::mutable_bulletin() {
  set_has_bulletin();
  if (bulletin_ == &::google::protobuf::internal::kEmptyString) {
    bulletin_ = new ::std::string;
  }
  return bulletin_;
}
inline ::std::string* S2C_Room::release_bulletin() {
  clear_has_bulletin();
  if (bulletin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bulletin_;
    bulletin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 mail = 4;
inline bool S2C_Room::has_mail() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void S2C_Room::set_has_mail() {
  _has_bits_[0] |= 0x00000008u;
}
inline void S2C_Room::clear_has_mail() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void S2C_Room::clear_mail() {
  mail_ = 0;
  clear_has_mail();
}
inline ::google::protobuf::int32 S2C_Room::mail() const {
  return mail_;
}
inline void S2C_Room::set_mail(::google::protobuf::int32 value) {
  set_has_mail();
  mail_ = value;
}

// -------------------------------------------------------------------

// C2S_TimeStamp

// required string timestamp = 1;
inline bool C2S_TimeStamp::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_TimeStamp::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_TimeStamp::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_TimeStamp::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& C2S_TimeStamp::timestamp() const {
  return *timestamp_;
}
inline void C2S_TimeStamp::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void C2S_TimeStamp::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void C2S_TimeStamp::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_TimeStamp::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* C2S_TimeStamp::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// S2C_TimeStamp

// required string timestamp = 1;
inline bool S2C_TimeStamp::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_TimeStamp::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_TimeStamp::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_TimeStamp::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& S2C_TimeStamp::timestamp() const {
  return *timestamp_;
}
inline void S2C_TimeStamp::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void S2C_TimeStamp::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void S2C_TimeStamp::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_TimeStamp::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* S2C_TimeStamp::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Equipment

// required string roleid = 1;
inline bool Equipment::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Equipment::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Equipment::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Equipment::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& Equipment::roleid() const {
  return *roleid_;
}
inline void Equipment::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void Equipment::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void Equipment::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Equipment::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* Equipment::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string elist = 2;
inline bool Equipment::has_elist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Equipment::set_has_elist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Equipment::clear_has_elist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Equipment::clear_elist() {
  if (elist_ != &::google::protobuf::internal::kEmptyString) {
    elist_->clear();
  }
  clear_has_elist();
}
inline const ::std::string& Equipment::elist() const {
  return *elist_;
}
inline void Equipment::set_elist(const ::std::string& value) {
  set_has_elist();
  if (elist_ == &::google::protobuf::internal::kEmptyString) {
    elist_ = new ::std::string;
  }
  elist_->assign(value);
}
inline void Equipment::set_elist(const char* value) {
  set_has_elist();
  if (elist_ == &::google::protobuf::internal::kEmptyString) {
    elist_ = new ::std::string;
  }
  elist_->assign(value);
}
inline void Equipment::set_elist(const char* value, size_t size) {
  set_has_elist();
  if (elist_ == &::google::protobuf::internal::kEmptyString) {
    elist_ = new ::std::string;
  }
  elist_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Equipment::mutable_elist() {
  set_has_elist();
  if (elist_ == &::google::protobuf::internal::kEmptyString) {
    elist_ = new ::std::string;
  }
  return elist_;
}
inline ::std::string* Equipment::release_elist() {
  clear_has_elist();
  if (elist_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = elist_;
    elist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// C2S_Property

// required string roleid = 1;
inline bool C2S_Property::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_Property::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_Property::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_Property::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& C2S_Property::roleid() const {
  return *roleid_;
}
inline void C2S_Property::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_Property::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_Property::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_Property::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* C2S_Property::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// S2C_Property

// required string roleid = 1;
inline bool S2C_Property::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_Property::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_Property::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_Property::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& S2C_Property::roleid() const {
  return *roleid_;
}
inline void S2C_Property::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_Property::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_Property::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_Property::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* S2C_Property::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string rolename = 2;
inline bool S2C_Property::has_rolename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2C_Property::set_has_rolename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2C_Property::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2C_Property::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& S2C_Property::rolename() const {
  return *rolename_;
}
inline void S2C_Property::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void S2C_Property::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void S2C_Property::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_Property::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* S2C_Property::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 pklevel = 3;
inline bool S2C_Property::has_pklevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void S2C_Property::set_has_pklevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void S2C_Property::clear_has_pklevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void S2C_Property::clear_pklevel() {
  pklevel_ = 0;
  clear_has_pklevel();
}
inline ::google::protobuf::int32 S2C_Property::pklevel() const {
  return pklevel_;
}
inline void S2C_Property::set_pklevel(::google::protobuf::int32 value) {
  set_has_pklevel();
  pklevel_ = value;
}

// required int32 pkexp = 4;
inline bool S2C_Property::has_pkexp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void S2C_Property::set_has_pkexp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void S2C_Property::clear_has_pkexp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void S2C_Property::clear_pkexp() {
  pkexp_ = 0;
  clear_has_pkexp();
}
inline ::google::protobuf::int32 S2C_Property::pkexp() const {
  return pkexp_;
}
inline void S2C_Property::set_pkexp(::google::protobuf::int32 value) {
  set_has_pkexp();
  pkexp_ = value;
}

// required int32 rankexp = 5;
inline bool S2C_Property::has_rankexp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void S2C_Property::set_has_rankexp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void S2C_Property::clear_has_rankexp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void S2C_Property::clear_rankexp() {
  rankexp_ = 0;
  clear_has_rankexp();
}
inline ::google::protobuf::int32 S2C_Property::rankexp() const {
  return rankexp_;
}
inline void S2C_Property::set_rankexp(::google::protobuf::int32 value) {
  set_has_rankexp();
  rankexp_ = value;
}

// required int32 ranklevel = 6;
inline bool S2C_Property::has_ranklevel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void S2C_Property::set_has_ranklevel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void S2C_Property::clear_has_ranklevel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void S2C_Property::clear_ranklevel() {
  ranklevel_ = 0;
  clear_has_ranklevel();
}
inline ::google::protobuf::int32 S2C_Property::ranklevel() const {
  return ranklevel_;
}
inline void S2C_Property::set_ranklevel(::google::protobuf::int32 value) {
  set_has_ranklevel();
  ranklevel_ = value;
}

// required int32 money = 7;
inline bool S2C_Property::has_money() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void S2C_Property::set_has_money() {
  _has_bits_[0] |= 0x00000040u;
}
inline void S2C_Property::clear_has_money() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void S2C_Property::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 S2C_Property::money() const {
  return money_;
}
inline void S2C_Property::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// required int32 gold = 8;
inline bool S2C_Property::has_gold() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void S2C_Property::set_has_gold() {
  _has_bits_[0] |= 0x00000080u;
}
inline void S2C_Property::clear_has_gold() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void S2C_Property::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 S2C_Property::gold() const {
  return gold_;
}
inline void S2C_Property::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
}

// required string items = 9;
inline bool S2C_Property::has_items() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void S2C_Property::set_has_items() {
  _has_bits_[0] |= 0x00000100u;
}
inline void S2C_Property::clear_has_items() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void S2C_Property::clear_items() {
  if (items_ != &::google::protobuf::internal::kEmptyString) {
    items_->clear();
  }
  clear_has_items();
}
inline const ::std::string& S2C_Property::items() const {
  return *items_;
}
inline void S2C_Property::set_items(const ::std::string& value) {
  set_has_items();
  if (items_ == &::google::protobuf::internal::kEmptyString) {
    items_ = new ::std::string;
  }
  items_->assign(value);
}
inline void S2C_Property::set_items(const char* value) {
  set_has_items();
  if (items_ == &::google::protobuf::internal::kEmptyString) {
    items_ = new ::std::string;
  }
  items_->assign(value);
}
inline void S2C_Property::set_items(const char* value, size_t size) {
  set_has_items();
  if (items_ == &::google::protobuf::internal::kEmptyString) {
    items_ = new ::std::string;
  }
  items_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_Property::mutable_items() {
  set_has_items();
  if (items_ == &::google::protobuf::internal::kEmptyString) {
    items_ = new ::std::string;
  }
  return items_;
}
inline ::std::string* S2C_Property::release_items() {
  clear_has_items();
  if (items_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = items_;
    items_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string equips = 10;
inline bool S2C_Property::has_equips() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void S2C_Property::set_has_equips() {
  _has_bits_[0] |= 0x00000200u;
}
inline void S2C_Property::clear_has_equips() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void S2C_Property::clear_equips() {
  if (equips_ != &::google::protobuf::internal::kEmptyString) {
    equips_->clear();
  }
  clear_has_equips();
}
inline const ::std::string& S2C_Property::equips() const {
  return *equips_;
}
inline void S2C_Property::set_equips(const ::std::string& value) {
  set_has_equips();
  if (equips_ == &::google::protobuf::internal::kEmptyString) {
    equips_ = new ::std::string;
  }
  equips_->assign(value);
}
inline void S2C_Property::set_equips(const char* value) {
  set_has_equips();
  if (equips_ == &::google::protobuf::internal::kEmptyString) {
    equips_ = new ::std::string;
  }
  equips_->assign(value);
}
inline void S2C_Property::set_equips(const char* value, size_t size) {
  set_has_equips();
  if (equips_ == &::google::protobuf::internal::kEmptyString) {
    equips_ = new ::std::string;
  }
  equips_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_Property::mutable_equips() {
  set_has_equips();
  if (equips_ == &::google::protobuf::internal::kEmptyString) {
    equips_ = new ::std::string;
  }
  return equips_;
}
inline ::std::string* S2C_Property::release_equips() {
  clear_has_equips();
  if (equips_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = equips_;
    equips_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string buffs = 11;
inline bool S2C_Property::has_buffs() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void S2C_Property::set_has_buffs() {
  _has_bits_[0] |= 0x00000400u;
}
inline void S2C_Property::clear_has_buffs() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void S2C_Property::clear_buffs() {
  if (buffs_ != &::google::protobuf::internal::kEmptyString) {
    buffs_->clear();
  }
  clear_has_buffs();
}
inline const ::std::string& S2C_Property::buffs() const {
  return *buffs_;
}
inline void S2C_Property::set_buffs(const ::std::string& value) {
  set_has_buffs();
  if (buffs_ == &::google::protobuf::internal::kEmptyString) {
    buffs_ = new ::std::string;
  }
  buffs_->assign(value);
}
inline void S2C_Property::set_buffs(const char* value) {
  set_has_buffs();
  if (buffs_ == &::google::protobuf::internal::kEmptyString) {
    buffs_ = new ::std::string;
  }
  buffs_->assign(value);
}
inline void S2C_Property::set_buffs(const char* value, size_t size) {
  set_has_buffs();
  if (buffs_ == &::google::protobuf::internal::kEmptyString) {
    buffs_ = new ::std::string;
  }
  buffs_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_Property::mutable_buffs() {
  set_has_buffs();
  if (buffs_ == &::google::protobuf::internal::kEmptyString) {
    buffs_ = new ::std::string;
  }
  return buffs_;
}
inline ::std::string* S2C_Property::release_buffs() {
  clear_has_buffs();
  if (buffs_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buffs_;
    buffs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PKProperty

// required string roleid = 1;
inline bool PKProperty::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKProperty::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKProperty::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKProperty::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& PKProperty::roleid() const {
  return *roleid_;
}
inline void PKProperty::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void PKProperty::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void PKProperty::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKProperty::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* PKProperty::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string rolename = 2;
inline bool PKProperty::has_rolename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKProperty::set_has_rolename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKProperty::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKProperty::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& PKProperty::rolename() const {
  return *rolename_;
}
inline void PKProperty::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void PKProperty::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void PKProperty::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKProperty::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* PKProperty::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 pklevel = 3;
inline bool PKProperty::has_pklevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PKProperty::set_has_pklevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PKProperty::clear_has_pklevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PKProperty::clear_pklevel() {
  pklevel_ = 0;
  clear_has_pklevel();
}
inline ::google::protobuf::int32 PKProperty::pklevel() const {
  return pklevel_;
}
inline void PKProperty::set_pklevel(::google::protobuf::int32 value) {
  set_has_pklevel();
  pklevel_ = value;
}

// required int32 pkexp = 4;
inline bool PKProperty::has_pkexp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PKProperty::set_has_pkexp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PKProperty::clear_has_pkexp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PKProperty::clear_pkexp() {
  pkexp_ = 0;
  clear_has_pkexp();
}
inline ::google::protobuf::int32 PKProperty::pkexp() const {
  return pkexp_;
}
inline void PKProperty::set_pkexp(::google::protobuf::int32 value) {
  set_has_pkexp();
  pkexp_ = value;
}

// required int32 ranklevel = 5;
inline bool PKProperty::has_ranklevel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PKProperty::set_has_ranklevel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PKProperty::clear_has_ranklevel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PKProperty::clear_ranklevel() {
  ranklevel_ = 0;
  clear_has_ranklevel();
}
inline ::google::protobuf::int32 PKProperty::ranklevel() const {
  return ranklevel_;
}
inline void PKProperty::set_ranklevel(::google::protobuf::int32 value) {
  set_has_ranklevel();
  ranklevel_ = value;
}

// required int32 rankexp = 6;
inline bool PKProperty::has_rankexp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PKProperty::set_has_rankexp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PKProperty::clear_has_rankexp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PKProperty::clear_rankexp() {
  rankexp_ = 0;
  clear_has_rankexp();
}
inline ::google::protobuf::int32 PKProperty::rankexp() const {
  return rankexp_;
}
inline void PKProperty::set_rankexp(::google::protobuf::int32 value) {
  set_has_rankexp();
  rankexp_ = value;
}

// required string items = 7;
inline bool PKProperty::has_items() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PKProperty::set_has_items() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PKProperty::clear_has_items() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PKProperty::clear_items() {
  if (items_ != &::google::protobuf::internal::kEmptyString) {
    items_->clear();
  }
  clear_has_items();
}
inline const ::std::string& PKProperty::items() const {
  return *items_;
}
inline void PKProperty::set_items(const ::std::string& value) {
  set_has_items();
  if (items_ == &::google::protobuf::internal::kEmptyString) {
    items_ = new ::std::string;
  }
  items_->assign(value);
}
inline void PKProperty::set_items(const char* value) {
  set_has_items();
  if (items_ == &::google::protobuf::internal::kEmptyString) {
    items_ = new ::std::string;
  }
  items_->assign(value);
}
inline void PKProperty::set_items(const char* value, size_t size) {
  set_has_items();
  if (items_ == &::google::protobuf::internal::kEmptyString) {
    items_ = new ::std::string;
  }
  items_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKProperty::mutable_items() {
  set_has_items();
  if (items_ == &::google::protobuf::internal::kEmptyString) {
    items_ = new ::std::string;
  }
  return items_;
}
inline ::std::string* PKProperty::release_items() {
  clear_has_items();
  if (items_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = items_;
    items_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string equips = 8;
inline bool PKProperty::has_equips() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PKProperty::set_has_equips() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PKProperty::clear_has_equips() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PKProperty::clear_equips() {
  if (equips_ != &::google::protobuf::internal::kEmptyString) {
    equips_->clear();
  }
  clear_has_equips();
}
inline const ::std::string& PKProperty::equips() const {
  return *equips_;
}
inline void PKProperty::set_equips(const ::std::string& value) {
  set_has_equips();
  if (equips_ == &::google::protobuf::internal::kEmptyString) {
    equips_ = new ::std::string;
  }
  equips_->assign(value);
}
inline void PKProperty::set_equips(const char* value) {
  set_has_equips();
  if (equips_ == &::google::protobuf::internal::kEmptyString) {
    equips_ = new ::std::string;
  }
  equips_->assign(value);
}
inline void PKProperty::set_equips(const char* value, size_t size) {
  set_has_equips();
  if (equips_ == &::google::protobuf::internal::kEmptyString) {
    equips_ = new ::std::string;
  }
  equips_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKProperty::mutable_equips() {
  set_has_equips();
  if (equips_ == &::google::protobuf::internal::kEmptyString) {
    equips_ = new ::std::string;
  }
  return equips_;
}
inline ::std::string* PKProperty::release_equips() {
  clear_has_equips();
  if (equips_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = equips_;
    equips_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string buffs = 9;
inline bool PKProperty::has_buffs() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PKProperty::set_has_buffs() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PKProperty::clear_has_buffs() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PKProperty::clear_buffs() {
  if (buffs_ != &::google::protobuf::internal::kEmptyString) {
    buffs_->clear();
  }
  clear_has_buffs();
}
inline const ::std::string& PKProperty::buffs() const {
  return *buffs_;
}
inline void PKProperty::set_buffs(const ::std::string& value) {
  set_has_buffs();
  if (buffs_ == &::google::protobuf::internal::kEmptyString) {
    buffs_ = new ::std::string;
  }
  buffs_->assign(value);
}
inline void PKProperty::set_buffs(const char* value) {
  set_has_buffs();
  if (buffs_ == &::google::protobuf::internal::kEmptyString) {
    buffs_ = new ::std::string;
  }
  buffs_->assign(value);
}
inline void PKProperty::set_buffs(const char* value, size_t size) {
  set_has_buffs();
  if (buffs_ == &::google::protobuf::internal::kEmptyString) {
    buffs_ = new ::std::string;
  }
  buffs_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKProperty::mutable_buffs() {
  set_has_buffs();
  if (buffs_ == &::google::protobuf::internal::kEmptyString) {
    buffs_ = new ::std::string;
  }
  return buffs_;
}
inline ::std::string* PKProperty::release_buffs() {
  clear_has_buffs();
  if (buffs_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buffs_;
    buffs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// C2S_PKList

// required string roleid = 1;
inline bool C2S_PKList::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_PKList::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_PKList::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_PKList::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& C2S_PKList::roleid() const {
  return *roleid_;
}
inline void C2S_PKList::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_PKList::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_PKList::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_PKList::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* C2S_PKList::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string request = 2;
inline bool C2S_PKList::has_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2S_PKList::set_has_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2S_PKList::clear_has_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2S_PKList::clear_request() {
  if (request_ != &::google::protobuf::internal::kEmptyString) {
    request_->clear();
  }
  clear_has_request();
}
inline const ::std::string& C2S_PKList::request() const {
  return *request_;
}
inline void C2S_PKList::set_request(const ::std::string& value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(value);
}
inline void C2S_PKList::set_request(const char* value) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(value);
}
inline void C2S_PKList::set_request(const char* value, size_t size) {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_PKList::mutable_request() {
  set_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    request_ = new ::std::string;
  }
  return request_;
}
inline ::std::string* C2S_PKList::release_request() {
  clear_has_request();
  if (request_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_;
    request_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PKTop

// required string roleid = 1;
inline bool PKTop::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PKTop::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PKTop::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PKTop::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& PKTop::roleid() const {
  return *roleid_;
}
inline void PKTop::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void PKTop::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void PKTop::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PKTop::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* PKTop::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 pkexp = 2;
inline bool PKTop::has_pkexp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PKTop::set_has_pkexp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PKTop::clear_has_pkexp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PKTop::clear_pkexp() {
  pkexp_ = 0;
  clear_has_pkexp();
}
inline ::google::protobuf::int32 PKTop::pkexp() const {
  return pkexp_;
}
inline void PKTop::set_pkexp(::google::protobuf::int32 value) {
  set_has_pkexp();
  pkexp_ = value;
}

// -------------------------------------------------------------------

// PKTopList

// repeated .PWRD.PKTop pktop = 1;
inline int PKTopList::pktop_size() const {
  return pktop_.size();
}
inline void PKTopList::clear_pktop() {
  pktop_.Clear();
}
inline const ::PWRD::PKTop& PKTopList::pktop(int index) const {
  return pktop_.Get(index);
}
inline ::PWRD::PKTop* PKTopList::mutable_pktop(int index) {
  return pktop_.Mutable(index);
}
inline ::PWRD::PKTop* PKTopList::add_pktop() {
  return pktop_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PWRD::PKTop >&
PKTopList::pktop() const {
  return pktop_;
}
inline ::google::protobuf::RepeatedPtrField< ::PWRD::PKTop >*
PKTopList::mutable_pktop() {
  return &pktop_;
}

// -------------------------------------------------------------------

// C2S_Bill

// required string roleid = 1;
inline bool C2S_Bill::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_Bill::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_Bill::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_Bill::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& C2S_Bill::roleid() const {
  return *roleid_;
}
inline void C2S_Bill::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_Bill::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_Bill::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_Bill::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* C2S_Bill::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string itemid = 2;
inline bool C2S_Bill::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2S_Bill::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2S_Bill::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2S_Bill::clear_itemid() {
  if (itemid_ != &::google::protobuf::internal::kEmptyString) {
    itemid_->clear();
  }
  clear_has_itemid();
}
inline const ::std::string& C2S_Bill::itemid() const {
  return *itemid_;
}
inline void C2S_Bill::set_itemid(const ::std::string& value) {
  set_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    itemid_ = new ::std::string;
  }
  itemid_->assign(value);
}
inline void C2S_Bill::set_itemid(const char* value) {
  set_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    itemid_ = new ::std::string;
  }
  itemid_->assign(value);
}
inline void C2S_Bill::set_itemid(const char* value, size_t size) {
  set_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    itemid_ = new ::std::string;
  }
  itemid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_Bill::mutable_itemid() {
  set_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    itemid_ = new ::std::string;
  }
  return itemid_;
}
inline ::std::string* C2S_Bill::release_itemid() {
  clear_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = itemid_;
    itemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 num = 3;
inline bool C2S_Bill::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void C2S_Bill::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void C2S_Bill::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void C2S_Bill::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 C2S_Bill::num() const {
  return num_;
}
inline void C2S_Bill::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// S2C_Bill

// required string roleid = 1;
inline bool S2C_Bill::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_Bill::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_Bill::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_Bill::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& S2C_Bill::roleid() const {
  return *roleid_;
}
inline void S2C_Bill::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_Bill::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_Bill::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_Bill::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* S2C_Bill::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 status = 2;
inline bool S2C_Bill::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2C_Bill::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2C_Bill::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2C_Bill::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 S2C_Bill::status() const {
  return status_;
}
inline void S2C_Bill::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// S2C_Gold

// required string roleid = 1;
inline bool S2C_Gold::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_Gold::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_Gold::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_Gold::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& S2C_Gold::roleid() const {
  return *roleid_;
}
inline void S2C_Gold::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_Gold::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_Gold::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_Gold::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* S2C_Gold::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 gold = 2;
inline bool S2C_Gold::has_gold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2C_Gold::set_has_gold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2C_Gold::clear_has_gold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2C_Gold::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 S2C_Gold::gold() const {
  return gold_;
}
inline void S2C_Gold::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
}

// -------------------------------------------------------------------

// C2S_Money

// required string roleid = 1;
inline bool C2S_Money::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_Money::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_Money::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_Money::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& C2S_Money::roleid() const {
  return *roleid_;
}
inline void C2S_Money::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_Money::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_Money::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_Money::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* C2S_Money::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 money = 2;
inline bool C2S_Money::has_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2S_Money::set_has_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2S_Money::clear_has_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2S_Money::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 C2S_Money::money() const {
  return money_;
}
inline void C2S_Money::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// -------------------------------------------------------------------

// C2S_PKStat

// required string roleid = 1;
inline bool C2S_PKStat::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_PKStat::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_PKStat::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_PKStat::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& C2S_PKStat::roleid() const {
  return *roleid_;
}
inline void C2S_PKStat::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_PKStat::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_PKStat::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_PKStat::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* C2S_PKStat::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// S2C_PKStat

// required string roleid = 1;
inline bool S2C_PKStat::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_PKStat::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_PKStat::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_PKStat::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& S2C_PKStat::roleid() const {
  return *roleid_;
}
inline void S2C_PKStat::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_PKStat::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_PKStat::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_PKStat::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* S2C_PKStat::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .PWRD.STAT stat = 2;
inline bool S2C_PKStat::has_stat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2C_PKStat::set_has_stat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2C_PKStat::clear_has_stat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2C_PKStat::clear_stat() {
  stat_ = 1;
  clear_has_stat();
}
inline PWRD::STAT S2C_PKStat::stat() const {
  return static_cast< PWRD::STAT >(stat_);
}
inline void S2C_PKStat::set_stat(PWRD::STAT value) {
  GOOGLE_DCHECK(PWRD::STAT_IsValid(value));
  set_has_stat();
  stat_ = value;
}

// -------------------------------------------------------------------

// S2C_PKList

// repeated .PWRD.PKProperty pkpro = 1;
inline int S2C_PKList::pkpro_size() const {
  return pkpro_.size();
}
inline void S2C_PKList::clear_pkpro() {
  pkpro_.Clear();
}
inline const ::PWRD::PKProperty& S2C_PKList::pkpro(int index) const {
  return pkpro_.Get(index);
}
inline ::PWRD::PKProperty* S2C_PKList::mutable_pkpro(int index) {
  return pkpro_.Mutable(index);
}
inline ::PWRD::PKProperty* S2C_PKList::add_pkpro() {
  return pkpro_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PWRD::PKProperty >&
S2C_PKList::pkpro() const {
  return pkpro_;
}
inline ::google::protobuf::RepeatedPtrField< ::PWRD::PKProperty >*
S2C_PKList::mutable_pkpro() {
  return &pkpro_;
}

// -------------------------------------------------------------------

// C2S_FightRequest

// required string roleid = 1;
inline bool C2S_FightRequest::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_FightRequest::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_FightRequest::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_FightRequest::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& C2S_FightRequest::roleid() const {
  return *roleid_;
}
inline void C2S_FightRequest::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_FightRequest::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_FightRequest::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_FightRequest::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* C2S_FightRequest::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string froleid = 2;
inline bool C2S_FightRequest::has_froleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2S_FightRequest::set_has_froleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2S_FightRequest::clear_has_froleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2S_FightRequest::clear_froleid() {
  if (froleid_ != &::google::protobuf::internal::kEmptyString) {
    froleid_->clear();
  }
  clear_has_froleid();
}
inline const ::std::string& C2S_FightRequest::froleid() const {
  return *froleid_;
}
inline void C2S_FightRequest::set_froleid(const ::std::string& value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void C2S_FightRequest::set_froleid(const char* value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void C2S_FightRequest::set_froleid(const char* value, size_t size) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_FightRequest::mutable_froleid() {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  return froleid_;
}
inline ::std::string* C2S_FightRequest::release_froleid() {
  clear_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = froleid_;
    froleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// S2C_FightRequest

// required string roleid = 1;
inline bool S2C_FightRequest::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_FightRequest::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_FightRequest::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_FightRequest::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& S2C_FightRequest::roleid() const {
  return *roleid_;
}
inline void S2C_FightRequest::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_FightRequest::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_FightRequest::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_FightRequest::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* S2C_FightRequest::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string froleid = 2;
inline bool S2C_FightRequest::has_froleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2C_FightRequest::set_has_froleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2C_FightRequest::clear_has_froleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2C_FightRequest::clear_froleid() {
  if (froleid_ != &::google::protobuf::internal::kEmptyString) {
    froleid_->clear();
  }
  clear_has_froleid();
}
inline const ::std::string& S2C_FightRequest::froleid() const {
  return *froleid_;
}
inline void S2C_FightRequest::set_froleid(const ::std::string& value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void S2C_FightRequest::set_froleid(const char* value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void S2C_FightRequest::set_froleid(const char* value, size_t size) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_FightRequest::mutable_froleid() {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  return froleid_;
}
inline ::std::string* S2C_FightRequest::release_froleid() {
  clear_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = froleid_;
    froleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// C2S_FightResponse

// required string roleid = 1;
inline bool C2S_FightResponse::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_FightResponse::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_FightResponse::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_FightResponse::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& C2S_FightResponse::roleid() const {
  return *roleid_;
}
inline void C2S_FightResponse::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_FightResponse::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_FightResponse::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_FightResponse::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* C2S_FightResponse::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string froleid = 2;
inline bool C2S_FightResponse::has_froleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2S_FightResponse::set_has_froleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2S_FightResponse::clear_has_froleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2S_FightResponse::clear_froleid() {
  if (froleid_ != &::google::protobuf::internal::kEmptyString) {
    froleid_->clear();
  }
  clear_has_froleid();
}
inline const ::std::string& C2S_FightResponse::froleid() const {
  return *froleid_;
}
inline void C2S_FightResponse::set_froleid(const ::std::string& value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void C2S_FightResponse::set_froleid(const char* value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void C2S_FightResponse::set_froleid(const char* value, size_t size) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_FightResponse::mutable_froleid() {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  return froleid_;
}
inline ::std::string* C2S_FightResponse::release_froleid() {
  clear_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = froleid_;
    froleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool ido = 3;
inline bool C2S_FightResponse::has_ido() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void C2S_FightResponse::set_has_ido() {
  _has_bits_[0] |= 0x00000004u;
}
inline void C2S_FightResponse::clear_has_ido() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void C2S_FightResponse::clear_ido() {
  ido_ = false;
  clear_has_ido();
}
inline bool C2S_FightResponse::ido() const {
  return ido_;
}
inline void C2S_FightResponse::set_ido(bool value) {
  set_has_ido();
  ido_ = value;
}

// -------------------------------------------------------------------

// S2C_FightResponse

// required string roleid = 1;
inline bool S2C_FightResponse::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_FightResponse::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_FightResponse::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_FightResponse::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& S2C_FightResponse::roleid() const {
  return *roleid_;
}
inline void S2C_FightResponse::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_FightResponse::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_FightResponse::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_FightResponse::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* S2C_FightResponse::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string froleid = 2;
inline bool S2C_FightResponse::has_froleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2C_FightResponse::set_has_froleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2C_FightResponse::clear_has_froleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2C_FightResponse::clear_froleid() {
  if (froleid_ != &::google::protobuf::internal::kEmptyString) {
    froleid_->clear();
  }
  clear_has_froleid();
}
inline const ::std::string& S2C_FightResponse::froleid() const {
  return *froleid_;
}
inline void S2C_FightResponse::set_froleid(const ::std::string& value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void S2C_FightResponse::set_froleid(const char* value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void S2C_FightResponse::set_froleid(const char* value, size_t size) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_FightResponse::mutable_froleid() {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  return froleid_;
}
inline ::std::string* S2C_FightResponse::release_froleid() {
  clear_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = froleid_;
    froleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool ido = 3;
inline bool S2C_FightResponse::has_ido() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void S2C_FightResponse::set_has_ido() {
  _has_bits_[0] |= 0x00000004u;
}
inline void S2C_FightResponse::clear_has_ido() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void S2C_FightResponse::clear_ido() {
  ido_ = false;
  clear_has_ido();
}
inline bool S2C_FightResponse::ido() const {
  return ido_;
}
inline void S2C_FightResponse::set_ido(bool value) {
  set_has_ido();
  ido_ = value;
}

// -------------------------------------------------------------------

// Beat

// required int32 hp = 1;
inline bool Beat::has_hp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Beat::set_has_hp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Beat::clear_has_hp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Beat::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 Beat::hp() const {
  return hp_;
}
inline void Beat::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// required string animation = 2;
inline bool Beat::has_animation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Beat::set_has_animation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Beat::clear_has_animation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Beat::clear_animation() {
  if (animation_ != &::google::protobuf::internal::kEmptyString) {
    animation_->clear();
  }
  clear_has_animation();
}
inline const ::std::string& Beat::animation() const {
  return *animation_;
}
inline void Beat::set_animation(const ::std::string& value) {
  set_has_animation();
  if (animation_ == &::google::protobuf::internal::kEmptyString) {
    animation_ = new ::std::string;
  }
  animation_->assign(value);
}
inline void Beat::set_animation(const char* value) {
  set_has_animation();
  if (animation_ == &::google::protobuf::internal::kEmptyString) {
    animation_ = new ::std::string;
  }
  animation_->assign(value);
}
inline void Beat::set_animation(const char* value, size_t size) {
  set_has_animation();
  if (animation_ == &::google::protobuf::internal::kEmptyString) {
    animation_ = new ::std::string;
  }
  animation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Beat::mutable_animation() {
  set_has_animation();
  if (animation_ == &::google::protobuf::internal::kEmptyString) {
    animation_ = new ::std::string;
  }
  return animation_;
}
inline ::std::string* Beat::release_animation() {
  clear_has_animation();
  if (animation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = animation_;
    animation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// C2S_Fight

// required string roleid = 1;
inline bool C2S_Fight::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_Fight::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_Fight::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_Fight::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& C2S_Fight::roleid() const {
  return *roleid_;
}
inline void C2S_Fight::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_Fight::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_Fight::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_Fight::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* C2S_Fight::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string froleid = 2;
inline bool C2S_Fight::has_froleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2S_Fight::set_has_froleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2S_Fight::clear_has_froleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2S_Fight::clear_froleid() {
  if (froleid_ != &::google::protobuf::internal::kEmptyString) {
    froleid_->clear();
  }
  clear_has_froleid();
}
inline const ::std::string& C2S_Fight::froleid() const {
  return *froleid_;
}
inline void C2S_Fight::set_froleid(const ::std::string& value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void C2S_Fight::set_froleid(const char* value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void C2S_Fight::set_froleid(const char* value, size_t size) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_Fight::mutable_froleid() {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  return froleid_;
}
inline ::std::string* C2S_Fight::release_froleid() {
  clear_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = froleid_;
    froleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .PWRD.Beat beat = 3;
inline bool C2S_Fight::has_beat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void C2S_Fight::set_has_beat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void C2S_Fight::clear_has_beat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void C2S_Fight::clear_beat() {
  if (beat_ != NULL) beat_->::PWRD::Beat::Clear();
  clear_has_beat();
}
inline const ::PWRD::Beat& C2S_Fight::beat() const {
  return beat_ != NULL ? *beat_ : *default_instance_->beat_;
}
inline ::PWRD::Beat* C2S_Fight::mutable_beat() {
  set_has_beat();
  if (beat_ == NULL) beat_ = new ::PWRD::Beat;
  return beat_;
}
inline ::PWRD::Beat* C2S_Fight::release_beat() {
  clear_has_beat();
  ::PWRD::Beat* temp = beat_;
  beat_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// S2C_Fight

// required string roleid = 1;
inline bool S2C_Fight::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_Fight::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_Fight::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_Fight::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& S2C_Fight::roleid() const {
  return *roleid_;
}
inline void S2C_Fight::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_Fight::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_Fight::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_Fight::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* S2C_Fight::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string froleid = 2;
inline bool S2C_Fight::has_froleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2C_Fight::set_has_froleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2C_Fight::clear_has_froleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2C_Fight::clear_froleid() {
  if (froleid_ != &::google::protobuf::internal::kEmptyString) {
    froleid_->clear();
  }
  clear_has_froleid();
}
inline const ::std::string& S2C_Fight::froleid() const {
  return *froleid_;
}
inline void S2C_Fight::set_froleid(const ::std::string& value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void S2C_Fight::set_froleid(const char* value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void S2C_Fight::set_froleid(const char* value, size_t size) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_Fight::mutable_froleid() {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  return froleid_;
}
inline ::std::string* S2C_Fight::release_froleid() {
  clear_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = froleid_;
    froleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .PWRD.Beat beat = 3;
inline bool S2C_Fight::has_beat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void S2C_Fight::set_has_beat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void S2C_Fight::clear_has_beat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void S2C_Fight::clear_beat() {
  if (beat_ != NULL) beat_->::PWRD::Beat::Clear();
  clear_has_beat();
}
inline const ::PWRD::Beat& S2C_Fight::beat() const {
  return beat_ != NULL ? *beat_ : *default_instance_->beat_;
}
inline ::PWRD::Beat* S2C_Fight::mutable_beat() {
  set_has_beat();
  if (beat_ == NULL) beat_ = new ::PWRD::Beat;
  return beat_;
}
inline ::PWRD::Beat* S2C_Fight::release_beat() {
  clear_has_beat();
  ::PWRD::Beat* temp = beat_;
  beat_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// C2S_HardBeat

// required string roleid = 1;
inline bool C2S_HardBeat::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_HardBeat::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_HardBeat::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_HardBeat::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& C2S_HardBeat::roleid() const {
  return *roleid_;
}
inline void C2S_HardBeat::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_HardBeat::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_HardBeat::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_HardBeat::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* C2S_HardBeat::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string froleid = 2;
inline bool C2S_HardBeat::has_froleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2S_HardBeat::set_has_froleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2S_HardBeat::clear_has_froleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2S_HardBeat::clear_froleid() {
  if (froleid_ != &::google::protobuf::internal::kEmptyString) {
    froleid_->clear();
  }
  clear_has_froleid();
}
inline const ::std::string& C2S_HardBeat::froleid() const {
  return *froleid_;
}
inline void C2S_HardBeat::set_froleid(const ::std::string& value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void C2S_HardBeat::set_froleid(const char* value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void C2S_HardBeat::set_froleid(const char* value, size_t size) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_HardBeat::mutable_froleid() {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  return froleid_;
}
inline ::std::string* C2S_HardBeat::release_froleid() {
  clear_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = froleid_;
    froleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .PWRD.Beat beat = 3;
inline bool C2S_HardBeat::has_beat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void C2S_HardBeat::set_has_beat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void C2S_HardBeat::clear_has_beat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void C2S_HardBeat::clear_beat() {
  if (beat_ != NULL) beat_->::PWRD::Beat::Clear();
  clear_has_beat();
}
inline const ::PWRD::Beat& C2S_HardBeat::beat() const {
  return beat_ != NULL ? *beat_ : *default_instance_->beat_;
}
inline ::PWRD::Beat* C2S_HardBeat::mutable_beat() {
  set_has_beat();
  if (beat_ == NULL) beat_ = new ::PWRD::Beat;
  return beat_;
}
inline ::PWRD::Beat* C2S_HardBeat::release_beat() {
  clear_has_beat();
  ::PWRD::Beat* temp = beat_;
  beat_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// S2C_HardBeat

// required string roleid = 1;
inline bool S2C_HardBeat::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_HardBeat::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_HardBeat::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_HardBeat::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& S2C_HardBeat::roleid() const {
  return *roleid_;
}
inline void S2C_HardBeat::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_HardBeat::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_HardBeat::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_HardBeat::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* S2C_HardBeat::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string froleid = 2;
inline bool S2C_HardBeat::has_froleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2C_HardBeat::set_has_froleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2C_HardBeat::clear_has_froleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2C_HardBeat::clear_froleid() {
  if (froleid_ != &::google::protobuf::internal::kEmptyString) {
    froleid_->clear();
  }
  clear_has_froleid();
}
inline const ::std::string& S2C_HardBeat::froleid() const {
  return *froleid_;
}
inline void S2C_HardBeat::set_froleid(const ::std::string& value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void S2C_HardBeat::set_froleid(const char* value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void S2C_HardBeat::set_froleid(const char* value, size_t size) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_HardBeat::mutable_froleid() {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  return froleid_;
}
inline ::std::string* S2C_HardBeat::release_froleid() {
  clear_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = froleid_;
    froleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .PWRD.Beat beat = 3;
inline bool S2C_HardBeat::has_beat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void S2C_HardBeat::set_has_beat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void S2C_HardBeat::clear_has_beat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void S2C_HardBeat::clear_beat() {
  if (beat_ != NULL) beat_->::PWRD::Beat::Clear();
  clear_has_beat();
}
inline const ::PWRD::Beat& S2C_HardBeat::beat() const {
  return beat_ != NULL ? *beat_ : *default_instance_->beat_;
}
inline ::PWRD::Beat* S2C_HardBeat::mutable_beat() {
  set_has_beat();
  if (beat_ == NULL) beat_ = new ::PWRD::Beat;
  return beat_;
}
inline ::PWRD::Beat* S2C_HardBeat::release_beat() {
  clear_has_beat();
  ::PWRD::Beat* temp = beat_;
  beat_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// QTE_Beat

// required int32 hp = 1;
inline bool QTE_Beat::has_hp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QTE_Beat::set_has_hp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QTE_Beat::clear_has_hp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QTE_Beat::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 QTE_Beat::hp() const {
  return hp_;
}
inline void QTE_Beat::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// required int32 during = 2;
inline bool QTE_Beat::has_during() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QTE_Beat::set_has_during() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QTE_Beat::clear_has_during() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QTE_Beat::clear_during() {
  during_ = 0;
  clear_has_during();
}
inline ::google::protobuf::int32 QTE_Beat::during() const {
  return during_;
}
inline void QTE_Beat::set_during(::google::protobuf::int32 value) {
  set_has_during();
  during_ = value;
}

// -------------------------------------------------------------------

// C2S_QTE

// required string roleid = 1;
inline bool C2S_QTE::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_QTE::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_QTE::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_QTE::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& C2S_QTE::roleid() const {
  return *roleid_;
}
inline void C2S_QTE::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_QTE::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_QTE::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_QTE::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* C2S_QTE::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string froleid = 2;
inline bool C2S_QTE::has_froleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2S_QTE::set_has_froleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2S_QTE::clear_has_froleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2S_QTE::clear_froleid() {
  if (froleid_ != &::google::protobuf::internal::kEmptyString) {
    froleid_->clear();
  }
  clear_has_froleid();
}
inline const ::std::string& C2S_QTE::froleid() const {
  return *froleid_;
}
inline void C2S_QTE::set_froleid(const ::std::string& value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void C2S_QTE::set_froleid(const char* value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void C2S_QTE::set_froleid(const char* value, size_t size) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_QTE::mutable_froleid() {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  return froleid_;
}
inline ::std::string* C2S_QTE::release_froleid() {
  clear_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = froleid_;
    froleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .PWRD.QTE_Beat qte = 3;
inline int C2S_QTE::qte_size() const {
  return qte_.size();
}
inline void C2S_QTE::clear_qte() {
  qte_.Clear();
}
inline const ::PWRD::QTE_Beat& C2S_QTE::qte(int index) const {
  return qte_.Get(index);
}
inline ::PWRD::QTE_Beat* C2S_QTE::mutable_qte(int index) {
  return qte_.Mutable(index);
}
inline ::PWRD::QTE_Beat* C2S_QTE::add_qte() {
  return qte_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PWRD::QTE_Beat >&
C2S_QTE::qte() const {
  return qte_;
}
inline ::google::protobuf::RepeatedPtrField< ::PWRD::QTE_Beat >*
C2S_QTE::mutable_qte() {
  return &qte_;
}

// -------------------------------------------------------------------

// S2C_QTE

// required string roleid = 1;
inline bool S2C_QTE::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_QTE::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_QTE::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_QTE::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& S2C_QTE::roleid() const {
  return *roleid_;
}
inline void S2C_QTE::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_QTE::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_QTE::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_QTE::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* S2C_QTE::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string froleid = 2;
inline bool S2C_QTE::has_froleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2C_QTE::set_has_froleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2C_QTE::clear_has_froleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2C_QTE::clear_froleid() {
  if (froleid_ != &::google::protobuf::internal::kEmptyString) {
    froleid_->clear();
  }
  clear_has_froleid();
}
inline const ::std::string& S2C_QTE::froleid() const {
  return *froleid_;
}
inline void S2C_QTE::set_froleid(const ::std::string& value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void S2C_QTE::set_froleid(const char* value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void S2C_QTE::set_froleid(const char* value, size_t size) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_QTE::mutable_froleid() {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  return froleid_;
}
inline ::std::string* S2C_QTE::release_froleid() {
  clear_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = froleid_;
    froleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .PWRD.QTE_Beat qte = 3;
inline int S2C_QTE::qte_size() const {
  return qte_.size();
}
inline void S2C_QTE::clear_qte() {
  qte_.Clear();
}
inline const ::PWRD::QTE_Beat& S2C_QTE::qte(int index) const {
  return qte_.Get(index);
}
inline ::PWRD::QTE_Beat* S2C_QTE::mutable_qte(int index) {
  return qte_.Mutable(index);
}
inline ::PWRD::QTE_Beat* S2C_QTE::add_qte() {
  return qte_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PWRD::QTE_Beat >&
S2C_QTE::qte() const {
  return qte_;
}
inline ::google::protobuf::RepeatedPtrField< ::PWRD::QTE_Beat >*
S2C_QTE::mutable_qte() {
  return &qte_;
}

// -------------------------------------------------------------------

// C2S_Item

// required string roleid = 1;
inline bool C2S_Item::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_Item::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_Item::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_Item::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& C2S_Item::roleid() const {
  return *roleid_;
}
inline void C2S_Item::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_Item::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_Item::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_Item::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* C2S_Item::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string froleid = 2;
inline bool C2S_Item::has_froleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2S_Item::set_has_froleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2S_Item::clear_has_froleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2S_Item::clear_froleid() {
  if (froleid_ != &::google::protobuf::internal::kEmptyString) {
    froleid_->clear();
  }
  clear_has_froleid();
}
inline const ::std::string& C2S_Item::froleid() const {
  return *froleid_;
}
inline void C2S_Item::set_froleid(const ::std::string& value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void C2S_Item::set_froleid(const char* value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void C2S_Item::set_froleid(const char* value, size_t size) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_Item::mutable_froleid() {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  return froleid_;
}
inline ::std::string* C2S_Item::release_froleid() {
  clear_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = froleid_;
    froleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string itemid = 3;
inline bool C2S_Item::has_itemid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void C2S_Item::set_has_itemid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void C2S_Item::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void C2S_Item::clear_itemid() {
  if (itemid_ != &::google::protobuf::internal::kEmptyString) {
    itemid_->clear();
  }
  clear_has_itemid();
}
inline const ::std::string& C2S_Item::itemid() const {
  return *itemid_;
}
inline void C2S_Item::set_itemid(const ::std::string& value) {
  set_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    itemid_ = new ::std::string;
  }
  itemid_->assign(value);
}
inline void C2S_Item::set_itemid(const char* value) {
  set_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    itemid_ = new ::std::string;
  }
  itemid_->assign(value);
}
inline void C2S_Item::set_itemid(const char* value, size_t size) {
  set_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    itemid_ = new ::std::string;
  }
  itemid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_Item::mutable_itemid() {
  set_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    itemid_ = new ::std::string;
  }
  return itemid_;
}
inline ::std::string* C2S_Item::release_itemid() {
  clear_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = itemid_;
    itemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// S2C_Item

// required string roleid = 1;
inline bool S2C_Item::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_Item::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_Item::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_Item::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& S2C_Item::roleid() const {
  return *roleid_;
}
inline void S2C_Item::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_Item::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_Item::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_Item::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* S2C_Item::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string froleid = 2;
inline bool S2C_Item::has_froleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2C_Item::set_has_froleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2C_Item::clear_has_froleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2C_Item::clear_froleid() {
  if (froleid_ != &::google::protobuf::internal::kEmptyString) {
    froleid_->clear();
  }
  clear_has_froleid();
}
inline const ::std::string& S2C_Item::froleid() const {
  return *froleid_;
}
inline void S2C_Item::set_froleid(const ::std::string& value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void S2C_Item::set_froleid(const char* value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void S2C_Item::set_froleid(const char* value, size_t size) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_Item::mutable_froleid() {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  return froleid_;
}
inline ::std::string* S2C_Item::release_froleid() {
  clear_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = froleid_;
    froleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string itemid = 3;
inline bool S2C_Item::has_itemid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void S2C_Item::set_has_itemid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void S2C_Item::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void S2C_Item::clear_itemid() {
  if (itemid_ != &::google::protobuf::internal::kEmptyString) {
    itemid_->clear();
  }
  clear_has_itemid();
}
inline const ::std::string& S2C_Item::itemid() const {
  return *itemid_;
}
inline void S2C_Item::set_itemid(const ::std::string& value) {
  set_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    itemid_ = new ::std::string;
  }
  itemid_->assign(value);
}
inline void S2C_Item::set_itemid(const char* value) {
  set_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    itemid_ = new ::std::string;
  }
  itemid_->assign(value);
}
inline void S2C_Item::set_itemid(const char* value, size_t size) {
  set_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    itemid_ = new ::std::string;
  }
  itemid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_Item::mutable_itemid() {
  set_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    itemid_ = new ::std::string;
  }
  return itemid_;
}
inline ::std::string* S2C_Item::release_itemid() {
  clear_has_itemid();
  if (itemid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = itemid_;
    itemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// S2C_FightResult

// required string roleid = 1;
inline bool S2C_FightResult::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_FightResult::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_FightResult::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_FightResult::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& S2C_FightResult::roleid() const {
  return *roleid_;
}
inline void S2C_FightResult::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_FightResult::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_FightResult::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_FightResult::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* S2C_FightResult::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string froleid = 2;
inline bool S2C_FightResult::has_froleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2C_FightResult::set_has_froleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2C_FightResult::clear_has_froleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2C_FightResult::clear_froleid() {
  if (froleid_ != &::google::protobuf::internal::kEmptyString) {
    froleid_->clear();
  }
  clear_has_froleid();
}
inline const ::std::string& S2C_FightResult::froleid() const {
  return *froleid_;
}
inline void S2C_FightResult::set_froleid(const ::std::string& value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void S2C_FightResult::set_froleid(const char* value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void S2C_FightResult::set_froleid(const char* value, size_t size) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_FightResult::mutable_froleid() {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  return froleid_;
}
inline ::std::string* S2C_FightResult::release_froleid() {
  clear_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = froleid_;
    froleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 win = 4;
inline bool S2C_FightResult::has_win() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void S2C_FightResult::set_has_win() {
  _has_bits_[0] |= 0x00000004u;
}
inline void S2C_FightResult::clear_has_win() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void S2C_FightResult::clear_win() {
  win_ = 0;
  clear_has_win();
}
inline ::google::protobuf::int32 S2C_FightResult::win() const {
  return win_;
}
inline void S2C_FightResult::set_win(::google::protobuf::int32 value) {
  set_has_win();
  win_ = value;
}

// required int32 type = 5;
inline bool S2C_FightResult::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void S2C_FightResult::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void S2C_FightResult::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void S2C_FightResult::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 S2C_FightResult::type() const {
  return type_;
}
inline void S2C_FightResult::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string equipment = 10;
inline bool S2C_FightResult::has_equipment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void S2C_FightResult::set_has_equipment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void S2C_FightResult::clear_has_equipment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void S2C_FightResult::clear_equipment() {
  if (equipment_ != &::google::protobuf::internal::kEmptyString) {
    equipment_->clear();
  }
  clear_has_equipment();
}
inline const ::std::string& S2C_FightResult::equipment() const {
  return *equipment_;
}
inline void S2C_FightResult::set_equipment(const ::std::string& value) {
  set_has_equipment();
  if (equipment_ == &::google::protobuf::internal::kEmptyString) {
    equipment_ = new ::std::string;
  }
  equipment_->assign(value);
}
inline void S2C_FightResult::set_equipment(const char* value) {
  set_has_equipment();
  if (equipment_ == &::google::protobuf::internal::kEmptyString) {
    equipment_ = new ::std::string;
  }
  equipment_->assign(value);
}
inline void S2C_FightResult::set_equipment(const char* value, size_t size) {
  set_has_equipment();
  if (equipment_ == &::google::protobuf::internal::kEmptyString) {
    equipment_ = new ::std::string;
  }
  equipment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_FightResult::mutable_equipment() {
  set_has_equipment();
  if (equipment_ == &::google::protobuf::internal::kEmptyString) {
    equipment_ = new ::std::string;
  }
  return equipment_;
}
inline ::std::string* S2C_FightResult::release_equipment() {
  clear_has_equipment();
  if (equipment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = equipment_;
    equipment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// C2S_FightResult

// required string roleid = 1;
inline bool C2S_FightResult::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_FightResult::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_FightResult::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_FightResult::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& C2S_FightResult::roleid() const {
  return *roleid_;
}
inline void C2S_FightResult::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_FightResult::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_FightResult::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_FightResult::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* C2S_FightResult::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string froleid = 2;
inline bool C2S_FightResult::has_froleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2S_FightResult::set_has_froleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2S_FightResult::clear_has_froleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2S_FightResult::clear_froleid() {
  if (froleid_ != &::google::protobuf::internal::kEmptyString) {
    froleid_->clear();
  }
  clear_has_froleid();
}
inline const ::std::string& C2S_FightResult::froleid() const {
  return *froleid_;
}
inline void C2S_FightResult::set_froleid(const ::std::string& value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void C2S_FightResult::set_froleid(const char* value) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(value);
}
inline void C2S_FightResult::set_froleid(const char* value, size_t size) {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  froleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_FightResult::mutable_froleid() {
  set_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    froleid_ = new ::std::string;
  }
  return froleid_;
}
inline ::std::string* C2S_FightResult::release_froleid() {
  clear_has_froleid();
  if (froleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = froleid_;
    froleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 win = 4;
inline bool C2S_FightResult::has_win() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void C2S_FightResult::set_has_win() {
  _has_bits_[0] |= 0x00000004u;
}
inline void C2S_FightResult::clear_has_win() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void C2S_FightResult::clear_win() {
  win_ = 0;
  clear_has_win();
}
inline ::google::protobuf::int32 C2S_FightResult::win() const {
  return win_;
}
inline void C2S_FightResult::set_win(::google::protobuf::int32 value) {
  set_has_win();
  win_ = value;
}

// required int32 type = 5;
inline bool C2S_FightResult::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void C2S_FightResult::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void C2S_FightResult::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void C2S_FightResult::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 C2S_FightResult::type() const {
  return type_;
}
inline void C2S_FightResult::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string equipment = 10;
inline bool C2S_FightResult::has_equipment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void C2S_FightResult::set_has_equipment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void C2S_FightResult::clear_has_equipment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void C2S_FightResult::clear_equipment() {
  if (equipment_ != &::google::protobuf::internal::kEmptyString) {
    equipment_->clear();
  }
  clear_has_equipment();
}
inline const ::std::string& C2S_FightResult::equipment() const {
  return *equipment_;
}
inline void C2S_FightResult::set_equipment(const ::std::string& value) {
  set_has_equipment();
  if (equipment_ == &::google::protobuf::internal::kEmptyString) {
    equipment_ = new ::std::string;
  }
  equipment_->assign(value);
}
inline void C2S_FightResult::set_equipment(const char* value) {
  set_has_equipment();
  if (equipment_ == &::google::protobuf::internal::kEmptyString) {
    equipment_ = new ::std::string;
  }
  equipment_->assign(value);
}
inline void C2S_FightResult::set_equipment(const char* value, size_t size) {
  set_has_equipment();
  if (equipment_ == &::google::protobuf::internal::kEmptyString) {
    equipment_ = new ::std::string;
  }
  equipment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_FightResult::mutable_equipment() {
  set_has_equipment();
  if (equipment_ == &::google::protobuf::internal::kEmptyString) {
    equipment_ = new ::std::string;
  }
  return equipment_;
}
inline ::std::string* C2S_FightResult::release_equipment() {
  clear_has_equipment();
  if (equipment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = equipment_;
    equipment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// C2S_Friend

// required string roleid = 1;
inline bool C2S_Friend::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_Friend::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_Friend::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_Friend::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& C2S_Friend::roleid() const {
  return *roleid_;
}
inline void C2S_Friend::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_Friend::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_Friend::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_Friend::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* C2S_Friend::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 num = 2;
inline bool C2S_Friend::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2S_Friend::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2S_Friend::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2S_Friend::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 C2S_Friend::num() const {
  return num_;
}
inline void C2S_Friend::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 index = 3;
inline bool C2S_Friend::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void C2S_Friend::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void C2S_Friend::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void C2S_Friend::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 C2S_Friend::index() const {
  return index_;
}
inline void C2S_Friend::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// optional int32 length = 4;
inline bool C2S_Friend::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void C2S_Friend::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void C2S_Friend::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void C2S_Friend::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 C2S_Friend::length() const {
  return length_;
}
inline void C2S_Friend::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// -------------------------------------------------------------------

// S2C_Friend

// required string roleid = 1;
inline bool S2C_Friend::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_Friend::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_Friend::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_Friend::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& S2C_Friend::roleid() const {
  return *roleid_;
}
inline void S2C_Friend::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_Friend::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_Friend::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_Friend::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* S2C_Friend::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string flist = 2;
inline bool S2C_Friend::has_flist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2C_Friend::set_has_flist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2C_Friend::clear_has_flist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2C_Friend::clear_flist() {
  if (flist_ != &::google::protobuf::internal::kEmptyString) {
    flist_->clear();
  }
  clear_has_flist();
}
inline const ::std::string& S2C_Friend::flist() const {
  return *flist_;
}
inline void S2C_Friend::set_flist(const ::std::string& value) {
  set_has_flist();
  if (flist_ == &::google::protobuf::internal::kEmptyString) {
    flist_ = new ::std::string;
  }
  flist_->assign(value);
}
inline void S2C_Friend::set_flist(const char* value) {
  set_has_flist();
  if (flist_ == &::google::protobuf::internal::kEmptyString) {
    flist_ = new ::std::string;
  }
  flist_->assign(value);
}
inline void S2C_Friend::set_flist(const char* value, size_t size) {
  set_has_flist();
  if (flist_ == &::google::protobuf::internal::kEmptyString) {
    flist_ = new ::std::string;
  }
  flist_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_Friend::mutable_flist() {
  set_has_flist();
  if (flist_ == &::google::protobuf::internal::kEmptyString) {
    flist_ = new ::std::string;
  }
  return flist_;
}
inline ::std::string* S2C_Friend::release_flist() {
  clear_has_flist();
  if (flist_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = flist_;
    flist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// C2S_AddFriend

// required string roleid = 1;
inline bool C2S_AddFriend::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2S_AddFriend::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2S_AddFriend::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2S_AddFriend::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& C2S_AddFriend::roleid() const {
  return *roleid_;
}
inline void C2S_AddFriend::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_AddFriend::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void C2S_AddFriend::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_AddFriend::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* C2S_AddFriend::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string flist = 2;
inline bool C2S_AddFriend::has_flist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2S_AddFriend::set_has_flist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2S_AddFriend::clear_has_flist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2S_AddFriend::clear_flist() {
  if (flist_ != &::google::protobuf::internal::kEmptyString) {
    flist_->clear();
  }
  clear_has_flist();
}
inline const ::std::string& C2S_AddFriend::flist() const {
  return *flist_;
}
inline void C2S_AddFriend::set_flist(const ::std::string& value) {
  set_has_flist();
  if (flist_ == &::google::protobuf::internal::kEmptyString) {
    flist_ = new ::std::string;
  }
  flist_->assign(value);
}
inline void C2S_AddFriend::set_flist(const char* value) {
  set_has_flist();
  if (flist_ == &::google::protobuf::internal::kEmptyString) {
    flist_ = new ::std::string;
  }
  flist_->assign(value);
}
inline void C2S_AddFriend::set_flist(const char* value, size_t size) {
  set_has_flist();
  if (flist_ == &::google::protobuf::internal::kEmptyString) {
    flist_ = new ::std::string;
  }
  flist_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2S_AddFriend::mutable_flist() {
  set_has_flist();
  if (flist_ == &::google::protobuf::internal::kEmptyString) {
    flist_ = new ::std::string;
  }
  return flist_;
}
inline ::std::string* C2S_AddFriend::release_flist() {
  clear_has_flist();
  if (flist_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = flist_;
    flist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// S2C_AddFriend

// required string roleid = 1;
inline bool S2C_AddFriend::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2C_AddFriend::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2C_AddFriend::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2C_AddFriend::clear_roleid() {
  if (roleid_ != &::google::protobuf::internal::kEmptyString) {
    roleid_->clear();
  }
  clear_has_roleid();
}
inline const ::std::string& S2C_AddFriend::roleid() const {
  return *roleid_;
}
inline void S2C_AddFriend::set_roleid(const ::std::string& value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_AddFriend::set_roleid(const char* value) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(value);
}
inline void S2C_AddFriend::set_roleid(const char* value, size_t size) {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  roleid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_AddFriend::mutable_roleid() {
  set_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    roleid_ = new ::std::string;
  }
  return roleid_;
}
inline ::std::string* S2C_AddFriend::release_roleid() {
  clear_has_roleid();
  if (roleid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleid_;
    roleid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string flist = 2;
inline bool S2C_AddFriend::has_flist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2C_AddFriend::set_has_flist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2C_AddFriend::clear_has_flist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2C_AddFriend::clear_flist() {
  if (flist_ != &::google::protobuf::internal::kEmptyString) {
    flist_->clear();
  }
  clear_has_flist();
}
inline const ::std::string& S2C_AddFriend::flist() const {
  return *flist_;
}
inline void S2C_AddFriend::set_flist(const ::std::string& value) {
  set_has_flist();
  if (flist_ == &::google::protobuf::internal::kEmptyString) {
    flist_ = new ::std::string;
  }
  flist_->assign(value);
}
inline void S2C_AddFriend::set_flist(const char* value) {
  set_has_flist();
  if (flist_ == &::google::protobuf::internal::kEmptyString) {
    flist_ = new ::std::string;
  }
  flist_->assign(value);
}
inline void S2C_AddFriend::set_flist(const char* value, size_t size) {
  set_has_flist();
  if (flist_ == &::google::protobuf::internal::kEmptyString) {
    flist_ = new ::std::string;
  }
  flist_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2C_AddFriend::mutable_flist() {
  set_has_flist();
  if (flist_ == &::google::protobuf::internal::kEmptyString) {
    flist_ = new ::std::string;
  }
  return flist_;
}
inline ::std::string* S2C_AddFriend::release_flist() {
  clear_has_flist();
  if (flist_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = flist_;
    flist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace PWRD

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< PWRD::TYPE>() {
  return PWRD::TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< PWRD::RESULT>() {
  return PWRD::RESULT_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< PWRD::STAT>() {
  return PWRD::STAT_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FightClub_2eproto__INCLUDED
